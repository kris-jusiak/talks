<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Run-time optimizations for compile-time reflection</title>

    <link rel="stylesheet" href="reveal.js/css/reveal.css">
    <link rel="stylesheet" href="reveal.js/css/theme/league.css" id="theme">
    <link rel="stylesheet" href="extensions/plugin/line-numbers/line-numbers.css">
    <link rel="stylesheet" href="extensions/css/highlight-styles/zenburn.css">
    <link rel="stylesheet" href="extensions/css/custom.css">

    <style>
      .reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5 { text-transform: none; }
    </style>

    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );

      function set_address(self, remote, local) {
        if (window.location.search.match("local")) {
          self.href = local;
        } else {
          self.href = remote;
        }
      }
    </script>

    <meta name="description" content="Compile-time reflections">
    <meta name="author" content="Kris Jusiak">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
          <script type="text/template">
          </script>
          </section>

          <section data-markdown=""
                   data-separator="^====+$"
                   data-separator-vertical="^----+$">
          <script type="text/template">
<!-- .element: data-background-image="images/cpponsea.png" -->

<br />&nbsp;
<br />&nbsp;
<br />&nbsp;
<br />&nbsp;
<br />&nbsp;
<br />&nbsp;
<br />&nbsp;
<img src="images/qr.png" style="width: 15%; background:none; border:none; box-shadow:none;" />

---

###### [kris@jusiak.net](mailto:kris@jusiak.net) | [@krisjusiak](https://twitter.com/krisjusiak) | [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)

----

#### Agenda

- #### Reflection
<!-- .element: class="fragment" -->

    - #### Introspection
    <!-- .element: class="fragment" -->

    - #### Meta-Programming
    <!-- .element: class="fragment" -->

- #### [Performance] Case study
<!-- .element: class="fragment" -->

    - ##### enum_to_string
    <!-- .element: class="fragment" -->

    - ##### string_to_enum
    <!-- .element: class="fragment" -->

- #### Examples
<!-- .element: class="fragment" -->

- #### Summary
<!-- .element: class="fragment" -->

----

#### Disclaimer

- ##### Proposal based ([P1306](https://wg21.link/P1306), [P1858](https://wg21.link/P1858), [P1928](https://wg21.link/P1928), [P2996](https://wg21.link/P2996), [P3294](https://wg21.link/P3294))
<!-- .element: class="fragment" -->

- ##### x86-64 focused
<!-- .element: class="fragment" -->

    - ##### https://github.com/bloomberg/clang-p2996
    <!-- .element: class="fragment" -->

- ##### C++20
<!-- .element: class="fragment" -->

  - ##### https://github.com/boost-ext
  <!-- .element: class="fragment" -->

----

#### Reflection for C++26 - https://wg21.link/P2996

- ##### Static (compile-time)
<!-- .element: class="fragment" data-fragment-index="0" -->

- ##### Value/consteval based
<!-- .element: class="fragment" data-fragment-index="1" -->

- ##### Supports introspection/meta-programming
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### P2996 - introspection

```cpp
namespace std::meta {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  // #member-queries
  consteval auto enumerators_of(info) -> vector<info>;
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  // #name and location
  consteval auto name_of(info) -> string_view;
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  // more...
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
using info = decltype(^::); // type-erased AST info
```
<!-- .element: class="fragment" data-fragment-index="4" -->

----

#### P2996 - meta-programming

```cpp
[: // splicer (reify)
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
  ^T // lift (reflexpr)
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
:]
```
<!-- .element: class="fragment" data-fragment-index="3" -->

---

```cpp
static_assert(
  typeid(^T) == typeid(meta::info)
);
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
static_assert(
  typeid(typename[:^int:]) == typeid(int)
);
```
<!-- .element: class="fragment" data-fragment-index="5" -->


----

##### P2996 / meta-programming (https://godbolt.org/z/43Yf8G8xz)

```cpp
template<size_t N, class... Ts>
using at =
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  typename [: // splicer (reify)
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
    array{^Ts...}[N] // lift into array{meta::info}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  :];
```
<!-- .element: class="fragment" data-fragment-index="2" -->

---

```cpp
static_assert(typeid(int)   == typeid(at<0, int, float, short>));
static_assert(typeid(float) == typeid(at<1, int, float, short>));
static_assert(typeid(short) == typeid(at<2, int, float, short>));
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

##### C++26 - Generalized pack declaration and usage (https://wg21.link/P1858)
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
template<size_t N, class... Ts>
using at = Ts...[N];
```
<!-- .element: class="fragment" data-fragment-index="4" -->


----

##### P2996 + ranges / meta-programming (https://godbolt.org/z/Y7edbe63c)

```cpp
template<class... Ts>
using reverse_drop_t = typename [:
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
    meta::substitute(^type_list,
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
        array{^Ts...} // array{meta::info}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
      | views::reverse
      | views::drop(1)
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
    )
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
:];
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
static_assert(typeid(reverse_drop_t<int, float, short>) ==
              typeid(type_list<float, int>));
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

##### P2996 - meta-programming / compilation times - https://github.com/boost-ext/mp/tree/benchmark

<a href="https://boost-ext.github.io/mp"><img src="images/bench.png" style="width: 100%; background:none; border:none; box-shadow:none;" /></a>

##### Meta-Programming model possible since C++17 (msvc, gcc, clang) - https://github.com/boost-ext/mp
<!-- .element: class="fragment" data-fragment-index="0" -->

----

### [Performance] Case study

----

#### Latency Numbers Every Programmer Should Know

| Operation          | Latency    |
| ------------------ | ---------- |
| L1 cache reference |     0.5 ns	|
| Branch mispredict	 |       5 ns	|
| L2 cache 	         |       7 ns	|
| Main memory reference |	   100 ns	|
| SSD read (1Mb)	   | 100'000 ns	|

----

### enum_to_string

----

### Enum - https://eel.is/c++draft/dcl.enum

----

#### Unscoped Enum (C-style Enum)

```cpp
enum color { red, green, blue, };
```
<!-- .element: class="fragment" -->

---

#### Scoped Enum (C++11)
<!-- .element: class="fragment" -->

```cpp
enum class http_status_code : uint32_t {
  ok = 200, not_found = 404, bad_gateway = 502,
};
```
<!-- .element: class="fragment" -->

---

#### 'Flag' Enum (not a standard term)
<!-- .element: class="fragment" -->

```cpp
enum class permissions : uint8_t {
  read     = (1 << 0), // 0b00000001
  write    = (1 << 1), // 0b00000010
  execute  = (1 << 2), // 0b00000100
};
```
<!-- .element: class="fragment" -->

----

#### enum_to_string - how hard it can be?

```cpp
enum { A = 1, B = 1, };
```
<!-- .element: class="fragment" -->

```cpp
enum_to_string(A); // ?
enum_to_string(B); // ?
```
<!-- .element: class="fragment" -->

---

```cpp
enum flag_enum { A = 0b01, B = 0b10, };
```
<!-- .element: class="fragment" -->

```cpp
enum_to_string(A | B); // ?
```
<!-- .element: class="fragment" -->

---

```cpp
enum E { A };
```
<!-- .element: class="fragment" -->

```cpp
enum_to_string(static_cast<E>(42)); // ?
```
<!-- .element: class="fragment" -->

----

#### enum_to_string - P2996

```
template <class E> requires is_enum_v<E>
constexpr auto enum_to_string(E value) -> string_view {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  template for (constexpr auto e : meta::enumerators_of(^E)) {
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
    if (value == [:e:]) {
      return meta::name_of(e);
    }
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
  }
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  return {};
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

##### Expansion statements* (https://wg21.link/P1306)
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### enum_to_string - P2996

```cpp
enum color { red, green, blue, };
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
template <class E> requires is_enum_v<E>
constexpr auto enum_to_string(E value) -> string_view {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  if (value == color::red)   { return "red"; }
  if (value == color::green) { return "green"; }
  if (value == color::blue)  { return "blue"; }

  return {};
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### LLVM Machine Code Analyzer - https://llvm.org/docs/CommandGuide/llvm-mca.html

```
$CXX
  -std=c++20
  -Ofast
  -DNDEBUG
  -mbmi2
  -mavx2
  -mllvm -x86-asm-syntax=intel
  -S -o -
| llvm-mca
  --mcpu=skylake
  --timeline
  --bottleneck-analysis
```
<!-- .element: class="fragment" data-fragment-index="0" -->

#### https://www.agner.org/optimize/instruction_tables.pdf
<!-- .element: class="fragment" data-fragment-index="1" -->

----

```sm
Dispatch Width:    6
uOps Per Cycle:    4.85
IPC:               4.85
Block RThroughput: 2.5

Instruction Info:
[1]: #uOps
[2]: Latency
[3]: RThroughput
[4]: MayLoad
[5]: MayStore
[6]: HasSideEffects (U)

[1]    [2]    [3]    [4]    [5]    [6]    Instructions:
 1      1     0.25                        test  edi, edi
 1      1     0.50                        je    .LBB0_1
 1      1     0.25                        cmp   edi, 1
 1      1     0.50                        jne   .LBB0_4
 1      1     0.50                        mov   eax, 5
 1      1     0.33                        lea   rdx, [rip + .L.str.1]
 1      5     0.50                  U     ret
 1      1     0.50                        mov   eax, 3
 1      1     0.33                        lea   rdx, [rip + .L.str]
 1      5     0.50                  U     ret
 1      1     0.50                        mov   eax, 4
 1      1     0.33                        lea   rdx, [rip + .L.str.2]
 1      5     0.50                  U     ret
 ```

----

#### Performance is a shape not a number!


----

#### switch-case

- ##### bitset (gcc)
- ##### jump table
- ##### decision-tree

- ##### different optimizations for Os/03

```cpp
--param case-values-threshold=<n>
-fjump-table
-fno-jump-table
```

----

#### P2996 - enumerators

```cpp
template<class E> requires is_enum_v<E>
inline constexpr auto enumerators =
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  []<size_t... Ns>(index_sequence<Ns...>) {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
    return array{
      pair{
        [: meta::enumerators_of(^E)[Ns] :],
        meta::name_of(meta::enumerators_of(^E)[Ns])
      }...
    };
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```
}(make_index_sequence<meta::enumerators_of(^E).size()>{});
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### P2996 - enumerators

```cpp
enum color { red, green, blue, };
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
static_assert(
  enumerators<color>
  ==
  array{
    pair{color::red, "red"},
    pair{color::green, "green"},
    pair{color::blue, "blue"},
  }
);
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### switch-case - https://godbolt.org/z/Mc5Yvsrxc

```cpp
template <class E> requires is_enum_v<E>
[[nodiscard]] constexpr auto enum_to_string(E value) {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  return [value]<size_t I = {}>(this auto&& self) -> string_view {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
    switch (value) {
      default:
        if constexpr (I < enumerators<E>.size() - 1u)
          return self.template operator()<I + 1u>();
        else
          return {};

      case enumerators<E>[I].first:
          return enumerators<E>[I].second;
    }
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  }();
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### P2996 / run-time / switch-case (https://godbolt.org/z/8reMEx3Yq)

        ```cpp
        template auto enum_to_string(E) -> string_view; // x86-64 -O3
        ```
        <!-- .element: class="fragment" -->

        ```cpp
        enum_to_string(E): // decision-tree for enum E
          cmp     edi, 1
          lea     rax, [rip + .L.str.2]
          lea     rcx, [rip + .L.str.1]
          cmove   rcx, rax
          test    edi, edi
          lea     rax, [rip + .L.str]
          cmovne  rax, rcx
          xor     edx, edx
          cmp     edi, 2
          setb    dl
          ret

        .L.str:   .asciz  "A"
        .L.str.2: .asciz  "B"
        .L.str.1: .zero   1
        ```
        <!-- .element: class="fragment" -->

  - __expected_probability  / if we know the order

    switch(a)
        case __expected_probability
        https://godbolt.org/z/8aWE4q6xW

    - Profile Guided Optimization (PGO)

----

#### P3294 - Code Injection with Token Sequences

----

CodeRecons - https://lists.isocpp.org/sg7/2024/04/0507.php

```cpp
consteval void gen_cases(auto& builder, auto cases) {
  for (auto e : constants(cases)) {
    append_case(builder, make_decl_ref_expr(e)); // case N:
    append_return(builder, name_of(e));          //   return "...";
  }
}
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
template<class E>
constexpr auto to_string(E value) {
  switch(value) {
    %gen_cases(^E); // code generation...
    default :
      return "";
  }
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### Want performance? Know your hardware!

----

- #### SIMD - Single Instruction, Multiple Data

  - std::simd - https://wg21.link/P1928
  <!-- .element: class="fragment" data-fragment-index="0" -->

----

### std::simd (x86-64)

```cpp
static_assert(4u  == simd_size_v<uint32_t>); // -msse     (128 bits)
static_assert(8u  == simd_size_v<uint32_t>); // -mavx     (256 bits)
static_assert(16u == simd_size_v<uint32_t>); // -mavx512f (512 bits)
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

### std::simd - https://godbolt.org/z/9c44jGnW6

```cpp
template <class E> requires is_enum_v<E> and
  (enumerators<E>.size() <= simd_size_v<underlying_type_t<E>>)
constexpr auto enum_to_string(E value) -> string_view {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
	simd<underlying_type_t<E>> lhs{value};
	simd<underlying_type_t<E>> rhs{[&](auto i) { return (i < enumerators<E>.size()) ? enumerators<E>[i].first : 0; }};
  const auto match = lhs == rhs;
  return any_of(match) ? enumerators<E>[find_first_set(match)].second : "";
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

### Perfect hashing - https://en.wikipedia.org/wiki/Perfect_hash_function

<img src="images/hashing.png" style="width: 100%; background:none; border:none; box-shadow:none;" />

- A collision of hashes occurs when a hash function yields the same value for two different keys.
- A perfect hash function is a hash function that does not yield any collisions for the given set of keys.
- A minimal perfect hash function (MPH) is a perfect hash function that maps the keys into the range from 0 to N-1, where N is the number of keys.

-----

##### Hash, Displace, Compress - https://link.springer.com/chapter/10.1007/978-3-642-04128-0_61
<a href="https://link.springer.com/chapter/10.1007/978-3-642-04128-0_61"><img src="images/hdc.png" style="width: 40%; background:none; border:none; box-shadow:none;" /></a>

----

##### PTHash - https://arxiv.org/pdf/2104.10402
<a href="https://arxiv.org/pdf/2104.10402"><img src="images/pthash.png" style="width: 53%; background:none; border:none; box-shadow:none;" /></a>

-----

<a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=pext_u64"><img src="images/pext.png" style="width: 100%; background:none; border:none; box-shadow:none;" /></a>

The instruction PEXT gets two arguments: the input word and the input mask. Bits from the input word for which the input mask is 1 are copied to the output. For example:

```cpp
word:   0010101011010111
mask:   0011100100100010
masked: __101__0__0___1_
pext:   __________101001
```

<a href="https://uops.info/table.html?search=PEXT%20(R64%2C%20R64%2C%20R64)&cb_lat=on&cb_SKL=on&cb_CFL=on&cb_CNL=on&cb_CLX=on&cb_ICL=on&cb_TGL=on&cb_RKL=on&cb_ADLE=on&cb_ZEN2=on&cb_ZEN3=on&cb_ZEN4=on&cb_measurements=on&cb_bmi=on"><img src="images/pext_lat.png" style="width: 100%; background:none; border:none; box-shadow:none;" /></a>

----

```cpp
template<class E, auto probability = 50u>
constexpr auto enum_to_string(const u64 lhs) const noexcept {
  static constexpr auto mask = mask<entries>;
  static constexpr auto lut = [] {
    std::array<std::pair<TKey, TMapped>, (1 << std::popcount(mask))> lut{};
    for (const auto& [key, value] : entries) lut[pext(key, mask)] = {key, value};
    return lut;
  }();

  auto&& [rhs, value] = lut[pext(lhs, mask)];
  return (lhs == rhs) * value; // we want: cmove, xor
}
```

----

find_mask

#pragma omp parallel

-----

compilation times


> [64 u32 keys] (https://godbolt.org/z/j8zWof5no)

```cpp
time $CXX -x c++ -O3 -std=c++20 mph -c -DNTEST        # 0.017s
time $CXX -x c++ -O3 -std=c++20 mph -c                # 0.056s
```

-----

#### Arm? No BMI2?

----

#### pseudo-pext

Luke Valenty: A case study in zero-cost abstractions: High performance message dispatch
  - https://schedule.cppnow.org/session/2024/a-case-study-in-zero-cost-abstractions-high-performance-message-dispatch/

```cpp
// bmi2
mov     ecx, 789
pext    ecx, eax, ecx
```

> [intel.com/pext](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=pext) / [uops.info/pext](https://uops.info/table.html?search=PEXT%20(R64%2C%20R64%2C%20R64)&cb_lat=on&cb_HSW=on&cb_BDW=on&cb_SKL=on&cb_CFL=on&cb_CLX=on&cb_ICL=on&cb_TGL=on&cb_RKL=on&cb_ZEN2=on&cb_ZEN3=on&cb_ZEN4=on&cb_measurements=on&cb_bmi=on)

```cpp
// no bmi2
mov     ecx, eax
and     ecx, 789
imul    ecx, ecx, 57
shr     ecx, 2
and     ecx, 248
```

----

probability
```cpp
          return T(cond * underlying(lhs.value), cond);
        } else if constexpr (requires { T(cond * underlying(lhs)); }) {
          return T(cond * underlying(lhs));
        } else {
          return __builtin_expect_with_probability(cond, 1, .5f) ? lhs : rhs;
```

safe$enum_to_string

unsafe$enum_to_string - probability = 100u

----

Note:
  `pext` on clang can be converted to `and`

----

#### What about `flag_enum`?

----

#### flag enum - https://godbolt.org/z/aM7E1bTPz

```cpp
template<class E> requires is_enum_v<E>
inline constexpr auto is_flag_enum_v = [] {
  for (const auto& enumeration : std::meta::enumerators_of(^E)) {
    if (not std::has_single_bit(std::to_underlying(enumeration))) {
      return false;
    }
  }
  return true;
}();
```

```cpp
enum class f1 { a = 0, b = 1, c = 2, };
enum class f2 { a = 1, b = 2, c = 16, };
enum class f3 { a = 1, b = 2, c = 7, };
static_assert(is_flag_enum_v<f1>);
static_assert(is_flag_enum_v<f2>);
static_assert(not is_flag_enum_v<f3>);
```

```cpp
template<class E> requires (is_scoped_enum_v<E> and is_flag_enum_v<E>)
[[nodiscard]] constexpr auto unsafe$enum_to_string(const E value) {
  static constexpr auto lut = [] {
    std::array<const char*, enumerators<E>.size()> lut{};
    for (auto i = 0u; const auto& [_, str] : enumerators<E>) lut[i++] = str;
    return lut;
  }();
  [[assume(std::popcount(std::to_underlying(value)) == 1u]];
  return lut[std::popcount(std::to_underlying(value)-1u)] // or clz
}
```

```cpp
unsafe$enum_2_string(permissions):
  decl    %edi
  popcntl %edi, %eax
  leaq    auto unsafe$enum_to_string<permissions>(T)::lut(%rip), %rcx
  movq    (%rcx,%rax,8), %rax
  retq

auto unsafe$enum_to_string<permissions>(T)::lut:
  .quad   .L.str
  .quad   .L.str.1
  .quad   .L.str.2

.L.str:   .asciz  "read"
.L.str.1: .asciz  "write"
.L.str.2: .asciz  "execute"
```

```cpp
Dispatch Width:    6
uOps Per Cycle:    4.59
IPC:               4.59
Block RThroughput: 1.0


Instruction Info:
[1]: #uOps
[2]: Latency
[3]: RThroughput
[4]: MayLoad
[5]: MayStore
[6]: HasSideEffects (U)

[1]    [2]    [3]    [4]    [5]    [6]    Instructions:
 1      1     0.25                        decl	%edi
 1      1     0.25                        popcntl	%edi, %eax
 1      1     0.33                        leaq	_ZZ21unsafe$enum_to_stringI11permissionsQaasr3stdE16is_scoped_enum_vIT_E14is_flag_enum_vIS1_EEDaS1_E3lut(%rip), %rcx
 1      5     0.33    *                   movq	(%rcx,%rax,8), %rax
 1      5     0.50                  U     retq
```

----

  and more ideas

  concepts based overload

    - concepts based overload (pick the best based)

```cpp
[[gnu::target("avx2")]] auto enum_to_string() reuqires entries.size() < 32
[[gnu::target("avx512f")]] auto enum_to_string() reuqires entries.size() < 32
```

----

#### More comprehensive benchmarks

show benchmarks

- https://github.com/boost-ext/mph/tree/benchmark

----

### string_to_enum

----

#### string_to_enum - https://godbolt.org/z/Yha87c9f3

```cpp
template<class E> requires is_enum_v<E>
constexpr auto string_to_enum(string_view str) -> optional<E> {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  if (str == "red") retun color::red;
  if (str == "green") retun color::green;
  if (str == "blue") retun color::blue;
  return nullopt;
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### string_to_enum - https://godbolt.org/z/Yha87c9f3

```cpp
template<class E> requires is_enum_v<E>
constexpr auto string_to_enum(string_view str) -> optional<E> {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  switch(hash(str)) {
    case hash("red"): return color::red;
    case hash("green"): return color::green;
    case hash("blue"): return color::blue;
  }
  return nullopt;
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### string_to_enum - https://godbolt.org/z/Yha87c9f3

```cpp
template<class E> requires is_enum_v<E>
constexpr auto string_to_enum(string_view str) -> optional<E> {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  switch(str[0]) {
    case 'r': return color::red;
    case 'g': return color::green;
    case 'b': return color::blue;
  }
  return nullopt;
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### string_to_enum - https://godbolt.org/z/Yha87c9f3

```cpp
template<class E> requires is_enum_v<E>
constexpr auto string_to_enum(string_view str) {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  static const unordered_map<string_view, E> map{
    {"red", color::red},
    {"green", color::green},
    {"blue", color::blue},
  };
  return map.at(str);
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

##### gperf - https://www.gnu.org/software/gperf

<a href="https://www.gnu.org/software/gperf/"><img src="images/gperf.png" style="width: 50%; background:none; border:none; box-shadow:none;" /></a>

----

#### frozen - https://github.com/serge-sans-paille/frozen
<a href="https://www.youtube.com/watch?v=vA5sdxbwUG8"><img src="images/frozen.png" style="width: 100%; background:none; border:none; box-shadow:none;" /></a>

----

### string_to_enum - can we do better?

----

#### string to type - https://godbolt.org/z/GnKoK9vrj

```cpp
static_assert(3+1 == sizeof("cpp"));
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```
uint32_t       :  4 bytes
uint64_t       :  8 bytes
simd<char, 16> : 16 bytes // x86.sse
simd<char, 32> : 32 bytes // x86.avx
simd<char, 64> : 64 bytes // x86.avx512
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

##### simd<char, N> can be used to implement optimized string
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### string to type - https://godbolt.org/z/GnKoK9vrj

```cpp
template<class T, auto Size> requires (Size <= sizeof(T))
constexpr auto to(const char (&str)[Size]) -> T {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  T t{};
  memcpy(&t, str, Size); // optimized
  return t;
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
template<class T>
constexpr auto to(string_view str) -> T {
  T t{};
  assert(str.size() <= sizeof(T));
  memcpy(&t, str.data(), str.size()); // slow
  return t;
}
```
<!-- .element: class="fragment" data-fragment-index="3" -->

----

#### string to type - https://godbolt.org/z/GnKoK9vrj

```cpp
template<class T>
constexpr auto to(string_view str) -> T {
  T t;
  memcpy(&t, str.data(), sizeof(t)); // potentially unsafe
  return bzhi(t, str.size() * CHAR_BIT);
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

<a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=bzhi"><img src="images/bzhi.png" style="width: 60%; background:none; border:none; box-shadow:none;" /></a>
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### string to type - https://godbolt.org/z/GnKoK9vrj

```cpp
[[gnu::target("default")]] auto bzhi(auto value, auto index) {
  return value & ((1u << index) - 1u);
}
[[gnu::target("bmi2")]] auto bzhi(uint32_t value, uint32_t index) {
  return _bzhi_u32(value, index);
}
[[gnu::target("bmi2")]] auto bzhi(uint64_t value, uint64_t index) {
  return _bzhi_u64(value, index);
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
template auto to<uint64_t>(string_view) -> uint64_t;
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
// $CXX -Ofast -DNDEBUG -mbmi2
shll    $3, %edi
bzhil   %edi, (%rsi), %eax
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### string to type - https://godbolt.org/z/GnKoK9vrj

```cpp
template<class T, size_t PAGE_SIZE = 4096u>
constexpr auto to(string_view str) {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  // https://github.com/glibc/blob/master/sysdeps/generic/memcopy.h
  if ((uint64_t(str.data()) & (PAGE_SIZE - 1ul)) >
      (PAGE_SIZE - sizeof(T))) [[unlikely]] { // page boundary
    return [&str] [[gnu::cold]] {
      T t;
      memcpy(&t, str.data(), str.size()); // slow path
      return t;
    }();
  }
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  T t{};
  memcpy(&t, str.data(), sizeof(t)); // fast path
  return bzhi(t, str.size() * CHAR_BIT);
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

### string_to_enum

----

#### Minimal perfect hashing

----

# bit mixer
```cpp
(x * magic) >> shift
```

```cpp
{1, 42, 17, 26}[i] // max 6 bits required to represent 42
{0b000001, 0b101010, 0b010001, 0b011010}[i]
(0b'011010'010001'101010'000001 >> 6*i) & 0b111111
```

```cpp
template<class E, size_t MaxAttempts = 100'000> requires is_enum_v<E>
constexpr auto string_to_enum(string_view str) -> E {
  constepxr auto [lut, magic, shift, mask] = [] {

    const auto nbits = [] {
      value_type max{};
      for (const auto& [_, v]: detail::traits<entries>::mappings) {
        if (value_type(v) > max) max = value_type(v);
      }
      return max ? (sizeof(value_type) * __CHAR_BIT__ - __builtin_clz(max)) : value_type{};
    }();
    mask = (1u << nbits) - 1u;
    shift = sizeof(value_type) * __CHAR_BIT__ - nbits;
    auto max_attempts = MaxAttempts;
    while (max_attempts--) {
      magic = random(); // compile-time random number generation
      T lut{};
      for (const auto& [k, v] : enumerators<E>) lut |= (v << (to<T>(k) * magic >> shift));
      for (const auto& [k, v] : enumerators<E>) {
        if ((lut >> (k * magic >> shift) & mask) != v) {
          E failed();
          return failed();
        }
      }
    }
    return std::tuple{lut, magic, shift, mask};
  }();
  return (lut >> ((to<T>(key) * magic) >> shift)) & mask;
}
```

----

```cpp
pext
```

----

simd

----

More comprehensive benchmarks

- https://github.com/boost-ext/mph/tree/benchmark

----

### Examples

----

#### Nasdaq TotalView-ITCH 5.0 - https://www.nasdaqtrader.com

<img src="images/nasdaq.png" style="width: 80%; background:none; border:none; box-shadow:none;" />

-----

#### Nasdaq TotalView-ITCH 5.0 - https://godbolt.org/z/n8Ex73e6P

```cpp
constexpr auto symbols = array{
  pair{"    AMZN"sv, 1},
  pair{"    AAPL"sv, 2},
  pair{"   GOOGL"sv, 3},
  pair{"    META"sv, 4},
  pair{"    MSFT"sv, 5},
  pair{"    NVDA"sv, 6},
  pair{"    TSLA"sv, 7},
};
```
<!-- .element: class="fragment" -->

```cpp
array<uint32_t, order_book> order_books{}; // 0 is special
```
<!-- .element: class="fragment" -->

```cpp
constexpr auto on(const add_order& msg) {
  order_book[*find<symbols>(msg.stock)].on(msg);
}
```
<!-- .element: class="fragment" -->

----

#### Nasdaq TotalView-ITCH 5.0 - https://godbolt.org/z/n8Ex73e6P

```cpp
on(add_order):
  mov     rax, qword ptr [rsi + 8]
  mov     rcx, qword ptr [rax]
  movabs  rax, 4419538124800
  pext    rdx, rcx, rax
  shl     edx, 4
  lea     rsi, [rip + find<symbols>]
  xor     eax, eax
  cmp     qword ptr [rdx + rsi], rcx
  cmove   eax, dword ptr [rdx + rsi + 8]
  ret
```

----

###### Uniform Resource Identifier (URI) schemes - https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml

https://godbolt.org/z/jnvMjns9f


```cpp
sall    $3, %edi
bzhi    %edi, (%rsi), %edi
imull   $385596323, %edi, %edi
movl    $358, %eax
shrl    $29, %edi
shrx    %edi, %eax, %eax
andl    $7, %eax
ret
```

----

example with minimal perfecth hash table

----

### Summary

----

#### Summary

- ##### Compile-time reflection opens new possibilities
<!-- .element: class="fragment" -->

- ##### There is no sliver bullet if it comes to the performance just trade-offs
<!-- .element: class="fragment" -->

- ##### Performance is a shape not a number (always measure)
<!-- .element: class="fragment" -->

----

### Let's embrace compile-time reflection!

---

- #### Reflection for C++ (https://wg21.link/P2996)
<!-- .element: class="fragment" -->

- #### C++20 (https://github.com/boost-ext/{mp,reflect,mph})
<!-- .element: class="fragment" -->

---

###### [kris@jusiak.net](mailto:kris@jusiak.net) | [@krisjusiak](https://twitter.com/krisjusiak) | [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)
          </script>
        </section>

      </div>
    </div>

    <script src="reveal.js/lib/js/head.min.js"></script>
    <script src="reveal.js/js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({

        // Display controls in the bottom right corner
        controls: false,

        // Display a presentation progress bar
        progress: false,

        // Display the page number of the current slide
        slideNumber: 'c/t',

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // Hides the address bar on mobile devices
        hideAddressBar: true,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style
        transition: 'none', // none/fade/slide/convex/concave/zoom

        // Transition speed
        transitionSpeed: 'default', // default/fast/slow

        // Transition style for full page slide backgrounds
        backgroundTransition: 'none', // none/fade/slide/convex/concave/zoom

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Parallax background image
        parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // Parallax background size
        parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

        // Number of pixels to move the parallax background per slide
        // - Calculated automatically unless specified
        // - Set to 0 to disable movement along an axis
        parallaxBackgroundHorizontal: null,
        parallaxBackgroundVertical: null,

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true },
          { src: 'extensions/plugin/line-numbers/line-numbers.js' }
        ]
      });

      <!--window.addEventListener("mousedown", handleClick, false);-->
      <!--window.addEventListener("contextmenu", function(e) { e.preventDefault(); }, false);-->

      function handleClick(e) {
        if (1 >= outerHeight - innerHeight) {
          document.querySelector( '.reveal' ).style.cursor = 'none';
        } else {
          document.querySelector( '.reveal' ).style.cursor = '';
        }

        e.preventDefault();
        if(e.button === 0) Reveal.next();
        if(e.button === 2) Reveal.prev();
      }
    </script>

  </body>
</html>
