<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Run-time optimizations for compile-time reflection</title>

    <link rel="stylesheet" href="reveal.js/css/reveal.css">
    <link rel="stylesheet" href="reveal.js/css/theme/league.css" id="theme">
    <link rel="stylesheet" href="extensions/plugin/line-numbers/line-numbers.css">
    <link rel="stylesheet" href="extensions/css/highlight-styles/zenburn.css">
    <link rel="stylesheet" href="extensions/css/custom.css">

    <style>
      .reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5 { text-transform: none; }
    </style>

    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );

      function set_address(self, remote, local) {
        if (window.location.search.match("local")) {
          self.href = local;
        } else {
          self.href = remote;
        }
      }
    </script>

    <meta name="description" content="Compile-time reflections">
    <meta name="author" content="Kris Jusiak">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
          <script type="text/template">
          </script>
          </section>

          <section data-markdown=""
                   data-separator="^====+$"
                   data-separator-vertical="^----+$">
          <script type="text/template">
<img src="images/cpponsea.svg" style="width: 10%; background:none; border:none; box-shadow:none;" />

---

## Run-time optimizations for compile-time reflection

<img src="images/qr.png" style="width: 15%; background:none; border:none; box-shadow:none;" />

---

###### [kris@jusiak.net](mailto:kris@jusiak.net) | [@krisjusiak](https://twitter.com/krisjusiak) | [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)

----

Disclaimer
  - mainly x86 based
  - proposal based (P2996, ...)
  - ideas translates to other cases
    - working solutions (mph)

Performance
   - there is no sliver bullet just trade-offs
   - know your data and your hardware!
   - measure in end-2-end setup!

Quick look at P2996

  - wg21.link/P2996

  - meta-programming model | ranges

    - compilation time benchmarks

    <a href="https://boost-ext.github.io/mp"><img src="images/bench.png" style="width: 100%; background:none; border:none; box-shadow:none;" /></a>
    <!-- .element: class="fragment" data-fragment-index="0" -->

      - mp - this model is possible since (C++17 with gcc,msvc,clang)

  - introspection

    - enumrations_of

----

Enum

<a href="https://eel.is/c++draft/dcl.enum#:%7b%7d,enum_declaration"><img src="images/enum.png" style="width: 100%; background:none; border:none; box-shadow:none;" /></a>

- Unscoped Enum (C-style Enum)

```cpp
enum color {
  RED,
  GREEN,
  BLUE,
};
```

- Scoped Enum (C++11)

```cpp
enum class coins : u8 {
  BTC = 1,
  ETH = 2,
  XRP = 3
};
```

---

- 'Flag' Enum

```cpp
enum Permissions : u8 {
  READ     = 1 << 0, // 0b00000001
  WRITE    = 1 << 1, // 0b00000010
  EXECUTE  = 1 << 2, // 0b00000100
};
```

----

enum_to_string

Challanges

    - multiple same values

    ```cpp
    enum { A = 1, B = 1, };
    ```

    enum_to_string(A);
    enum_to_string(B);

    - flag-enum

    enum { A = 0b01, B = 0b10, };

    enum_to_string(A | B);

- unknown value

    enum E { A };
    - enum_to_string(static_cast<E>(42));

        - ""
        - std::optional / std::expected
        - enum_to_string<"unknown">(static_cast<E>(42));

---

- P2996 (examples)

  - template for
  ```
  template <class E> requires std::is_enum_v<E>
  constexpr auto enum_to_string(E value) {
    template for (constexpr auto e : std::meta::enumerators_of(^E)) {
      if (value == [:e:]) {
        return std::meta::name_of(e);
      }
    }
    return "<unnamed>";
  }
  enum Color { red, green, blue };
  static_assert(enum_to_string(Color::red) == "red");
  static_assert(enum_to_string(Color(42)) == "<unnamed>");
  ```

    ##### Expansion statements* (https://wg21.link/P1306)
        <!-- .element: class="fragment" data-fragment-index="0" -->

  - P2996

      <img src="images/enum_p2996.png" style="width: 100%; background:none; border:none; box-shadow:none;" />

- switch-case
    - how does it work in gcc (https://xoranth.net/gcc-switch/)
    - Notes: different optimizations for -Os/-O3

    --param case-values-threshold=<n>: The smallest number of different values for which it is best to use a jump-table instead of a tree of conditional branches, if 0, use the default for the machine.
    -fjump-table: Use jump tables for sufficiently large switch statements
    -fno-jump-table: Do not use jump tables for sufficiently large switch statements

  - switch-case P2996 - https://godbolt.org/z/Mc5Yvsrxc
    - nested switch

        - based on optimizations


  - P3294 - Code Injection with Token Sequences
    - string baesd

  - CodeRecons - https://lists.isocpp.org/sg7/2024/04/0507.php

    - example

- simd

    - x86
        - sse2   (128 bits - 16xu8, 4xu32, 2xu64)  // 16aligned
        - avx2   (256 bits - 32xu8, 8xu32, 4xu64)  // 32aligned
        - avx512 (512 bits - 64xu8, 16xu32, 8xu64) // 64aligned
        - ...

    - aligned/unaligned load

- perfect-hashing
   - https://en.wikipedia.org/wiki/Perfect_hash_function

   - can be done at run-time or compile-time (which we will focus on)

  - explain

      <img src="images/hashing.png" style="width: 100%; background:none; border:none; box-shadow:none;" />

      A collision of hashes occurs when a hash function yields the same value for two different keys.
      A perfect hash function is a hash function that does not yield any collisions for the given set of keys.
      A minimal perfect hash function (MPH) is a perfect hash function that maps the keys into the range from 0 to N-1, where N is the number of keys.

      <a href="https://www.youtube.com/watch?v=yOo6GnbKzp8"><img src="images/mph.png" style="width: 100%; background:none; border:none; box-shadow:none;" /></a>

    - approaches

    - frozen
      <a href="http://stevehanov.ca/blog/index.php?id=119"><img src="images/phash.png" style="width: 100%; background:none; border:none; box-shadow:none;" /></a>

        <a href="https://www.youtube.com/watch?v=vA5sdxbwUG8"><img src="images/frozen.png" style="width: 100%; background:none; border:none; box-shadow:none;" /></a>

    - pthash

      <a href="https://www.youtube.com/watch?v=3kjWMbuD1U4"><img src="images/pthash.png" style="width: 100%; background:none; border:none; box-shadow:none;" /></a>
        https://github.com/jermp/pthash

    - pext

      <a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=pext_u64"><img src="images/pext.png" style="width: 100%; background:none; border:none; box-shadow:none;" /></a>

        The instruction PEXT gets two arguments: the input word and the input mask. Bits from the input word for which the input mask is 1 are copied to the output. For example:

        ```cpp
        word:   0010101011010111
        mask:   0011100100100010
        masked: __101__0__0___1_
        pext:   __________101001
        ```

        ```cpp
        template<class T>
        constexpr auto pext(const T a, T mask) -> T {
          T result{};
          auto k = 0u;
          for (T i{}; i < size; ++i) {
            if (mask & 1) result |= ((a >> i) & 1) << k++;
            mask >>= 1;
          }
          return result;
        }
        ```

        ```cpp
        static_assert(0b00 == mph::detail::pext(0b00, 0b00));
        static_assert(0b00 == mph::detail::pext(0b01, 0b00));
        static_assert(0b01 == mph::detail::pext(0b01, 0b01));
        static_assert(0b01 == mph::detail::pext(0b01, 0b11));
        static_assert(0b00 == mph::detail::pext(0b01, 0b10));
        static_assert(0b01 == mph::detail::pext(0b11, 0b10));
        static_assert(0b01 == mph::detail::pext(0b11, 0b01));
        static_assert(0b11 == mph::detail::pext(0b11, 0b11));
        ```

      def lookup[kv: array](key : any):
        # 0. find mask which uniquely identifies all keys [compile-time]
        mask = ~typeof(kv[0][0]) # 0b111111...

        for i in range(nbits(mask)):
          masked = []
          mask.unset(i)

          for k, v in kv:
            masked.append(k & mask)

          if not unique(masked):
            mask.set(i)

        assert unique(masked)
        assert mask != ~typeof(kv[0][0])

        lookup = array(typeof(kv[0]), 2^popcount(mask)) # static constexpr + alignment
        for k, v in kv:
          lookup[pext(k, mask)] = (k, v)

        # 1. lookup [run-time] / if key is a string convert to integral first (memcpy)
          # word: 00101011
          # mask: 11100001
          #    &: 000____1
          # pext: ____0001 # intel/intrinsics-guide/index.html#text=pext
          def pext(a : uN, mask : uN):
            dst, m, k = ([], 0, 0)

            while m < nbits(a):
              if mask[m] == 1:
                dst.append(a[m])
                k += 1
              m += 1

            return uN(dst)

        k, v = lookup[pext(key, mask)]

        if k == key:
          return v
        else:
          return 0

        - considerations

            - lookup table size

        - challenges
          - mask implementation (compilatie-time intensive - whould be nice to have pragma for, linear probing)

            ```cpp
            template<class T, u32 N, auto unknown = false>
            [[nodiscard]] constexpr auto mask(const auto& entries) noexcept -> T {
              utility::array<T, decltype(entries){}.size()> vs;
              T max{};
              u32 size{};
              for (auto i = 0u; i < vs.size(); ++i) {
                if (unknown and not entries[i].first) break;
                if (vs[i] = entries[i].first; vs[i] > max) max = vs[i];
                ++size;
              }
              if (size <= 1u) {
                return {};
              }
              constexpr auto H = (N * vs.size()) << 1u;
              constexpr auto N_ = N - 1u;
              const auto clz = sizeof(max) <= sizeof(u32) ? __builtin_clz(max) : __builtin_clzl(max);
              const auto nbits = sizeof(T) * __CHAR_BIT__ - clz - 1u;
              utility::array<T, H> hashed;
              T mask = ((T(1) << nbits) - 1u);
              for (int i = nbits; i >= 0; --i) {
                mask &= ~(T(1) << i);
                hashed = {};
                for (auto j = 0u; j < size; ++j) {
                  const T masked = (vs[j] & mask) + 1u;
                  auto slot = masked % H;
                  auto n = N_;
                  auto found = false;
                  while (hashed[slot]) {
                    if (hashed[slot] == masked and not n--) {
                      found = true;
                      break;
                    }
                    slot = (slot + 1u) % H;
                  }
                  if (found) {
                    mask |= (T(1) << i);
                    break;
                  }
                  hashed[slot] = masked;
                }
              }
              return mask;
            }
            ```

                - compilation times

                    > [64 u32 keys] (https://godbolt.org/z/j8zWof5no)

                    ```cpp
                    time $CXX -std=c++20 u32_64.cpp -c # 0.043s
                    ```

                    ```cpp
                    time $CXX -std=c++20 str_327658.cpp -c -DNTEST    # 0.043s
                    time $CXX -std=c++20 str_32768.cpp -c            # 0.090s
                    ```


                # pragma omp parallel for

          - amd zen2

            <a href="https://uops.info/table.html?search=PEXT%20(R64%2C%20R64%2C%20R64)&cb_lat=on&cb_SKL=on&cb_CFL=on&cb_CNL=on&cb_CLX=on&cb_ICL=on&cb_TGL=on&cb_RKL=on&cb_ADLE=on&cb_ZEN2=on&cb_ZEN3=on&cb_ZEN4=on&cb_measurements=on&cb_bmi=on"><img src="images/pext_lat.png" style="width: 100%; background:none; border:none; box-shadow:none;" /></a>

            arm doesn't have it

          - pseudo-pext (Luke)

              ```cpp
              // bmi2
              mov     ecx, 789
              pext    ecx, eax, ecx
              ```

              > [intel.com/pext](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=pext) / [uops.info/pext](https://uops.info/table.html?search=PEXT%20(R64%2C%20R64%2C%20R64)&cb_lat=on&cb_HSW=on&cb_BDW=on&cb_SKL=on&cb_CFL=on&cb_CLX=on&cb_ICL=on&cb_TGL=on&cb_RKL=on&cb_ZEN2=on&cb_ZEN3=on&cb_ZEN4=on&cb_measurements=on&cb_bmi=on)

              ```cpp
              // no bmi2
              mov     ecx, eax
              and     ecx, 789
              imul    ecx, ecx, 57
              shr     ecx, 2
              and     ecx, 248
              ```

              Note:
                `pext` on clang can be converted to `and`

      - probability
        - generting cmove

            - unpredictable branch cost

        - safe/unsafe
          - $unsafe - when we can guranatee no hacking

    - flag enum
        ```cpp
        template<class E> requires std::is_enum_v<E>
        inline constexpr auto is_flag_enum_v = [] {
          for (const auto& enumeration : std::meta::enumerators_of(^E)) {
            if (not std::has_single_bit(std::to_underlying(std::meta::extract<E>(enumeration)))) {
              return false;
            }
          }
          return true;
        }();
        ```

        ```cpp
        enum class f1 { a = 0, b = 1, c = 2, };
        enum class f2 { a = 1, b = 2, c = 16, };
        enum class f3 { a = 1, b = 2, c = 7, };
        static_assert(is_flag_enum_v<f1>);
        static_assert(is_flag_enum_v<f2>);
        static_assert(not is_flag_enum_v<f3>);
        ```

        - https://godbolt.org/z/aM7E1bTPz

    - pext + simd

    - concepts based overload (pick the best based)

    ```cpp
    requires requires
    if constexpr () {}
    ```

More benchmarks
    - https://github.com/boost-ext/mph

----

string_to_enum

  - regex, if-else, map, unordered_map, state machines, ...

    - crte string

  - swar switch case with hash

    to_uint64(std::string_view);

    ```cpp
      // https://github.com/glibc/blob/master/sysdeps/generic/memcopy.h#L162
      if ((u64(data.data()) & (PAGE_SIZE - 1ul)) > (PAGE_SIZE - sizeof(T))) [[unlikely]] {
        return [&data] [[gnu::cold]] {
          T t{};
          std::memcpy(&t, data.data(), data.size()); // slow
          return t;
        }();
      }
    ```

    ```cpp
      T t;
      __builtin_memcpy(&t, data.data(), sizeof(t));
      const auto index = data.size() * CHAR_BIT;
      return __builtin_ia32_bzhi_di(t, index);
    ```

  - gperf
    string onlye
    <a href="https://www.gnu.org/software/gperf/"><img src="images/gperf.png" style="width: 100%; background:none; border:none; box-shadow:none;" /></a>

  - perfect hashing
  - simd
  - <=8 characters (uin64)

    - real life

        Nasdaq TotalView-ITCH 5.0

        <a href="https://www.nasdaqtrader.com/content/technicalsupport/specifications/dataproducts/NQTVITCHSpecification.pdf"><img src="images/nasdaq.png" style="width: 100%; background:none; border:none; box-shadow:none;" /></a>

            std::pair{"AMZN    "sv, 1},
            std::pair{"AAPL    "sv, 2},
            std::pair{"GOOGL   "sv, 3},
            std::pair{"META    "sv, 4},
            std::pair{"MSFT    "sv, 5},
            std::pair{"NVDA    "sv, 6},
            std::pair{"TSLA    "sv, 7},

        - Uniform Resource Identifier (URI) schemes

            - https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml

            pair("ftp",  1),
            pair("file",  2),
            pair("http", 3),
            pair("https",  4),
            pair("ws",  5),
            pair("wss",  6),

More benchmarks
    - https://github.com/boost-ext/mph
----

Summary

    - P2996 is powerful
    - perfect hashing can be powerful tool for improving performance
    - There is no silver bullet if it comes to the performance just trade-offs
    - The more you know about your data the more you can optimize it

----

Credits
  - 0x80, lemiare, intel-manul, gperf, llvm-mca
  - fagner, uops, llvm-mca, godbolt
  - mph

----

#### Agenda

* #### Motivation
<!-- .element: class="fragment" -->

* #### Reflection
<!-- .element: class="fragment" -->

    * #### Meta-programming
    <!-- .element: class="fragment" -->

    * #### Introspection
    <!-- .element: class="fragment" -->

    * #### Injection
    <!-- .element: class="fragment" -->

    * #### Performance
    <!-- .element: class="fragment" -->

* #### Summary
<!-- .element: class="fragment" -->

----

#### Disclaimer - syntax heavy!

- ##### Based on proposals
<!-- .element: class="fragment" -->

- ##### Powered by Compiler Explorer (https://godbolt.org)
<!-- .element: class="fragment" -->

  - ##### Clang (https://github.com/bloomberg/clang-p2996)
  <!-- .element: class="fragment" -->

  - ##### EDG (https://www.edg.com)
  <!-- .element: class="fragment" -->

----

#### Motivation

- ##### Correctness/safety
<!-- .element: class="fragment" -->

- ##### Performance
<!-- .element: class="fragment" -->

- ##### Maintability/Flexibility/Debuggability
<!-- .element: class="fragment" -->

- ##### ...
<!-- .element: class="fragment" -->

----

##### Reflection

- ##### What?
  - ##### Introspection
<!-- .element: class="fragment" -->
      - ##### get enum name, get members of a struct
<!-- .element: class="fragment" -->
      - ##### find all functions in the namespace
<!-- .element: class="fragment" -->
      - ##### ...
<!-- .element: class="fragment" -->

  - ##### Injection/Code generation
<!-- .element: class="fragment" -->
      - ##### convert array of structs to struct of arrays (SoA)
<!-- .element: class="fragment" -->
      - ##### generate switch case
<!-- .element: class="fragment" -->
      - ##### ...
<!-- .element: class="fragment" -->

----

##### Reflection

- ##### How?

  - ##### code generation (libclang + cmake)
<!-- .element: class="fragment" -->

  - ##### compiler hacks (\_\_PRETTY_FUNCTION__, friend injection)
<!-- .element: class="fragment" -->

  - ##### compiler builtins (\__builtin_dump_struct - clang)
<!-- .element: class="fragment" -->

  - ##### compilers with reflection (https://www.circle-lang.org)
<!-- .element: class="fragment" -->

  - ##### language support
<!-- .element: class="fragment" -->
    - ##### C++2X - meta-classes (https://github.com/hsutter/cppfront)
<!-- .element: class="fragment" -->
    - ##### C++2X - mirror (https://wg21.link/P0385)
<!-- .element: class="fragment" -->
    - ##### Reflection for C++26* (https://wg21.link/P2996)
<!-- .element: class="fragment" -->

----

### Reflection for C++26 (https://wg21.link/P2996)

----

##### Reflection for C++26 (https://wg21.link/P2996)

- ##### static (compile-time)
<!-- .element: class="fragment" data-fragment-index="0" -->

  - ##### value/consteval based
  <!-- .element: class="fragment" data-fragment-index="1" -->

    ```cpp
    [: // splicer (reify)
    ```
    <!-- .element: class="fragment" data-fragment-index="3" -->

    ```cpp
      ^T // lift (reflexpr)
    ```
    <!-- .element: class="fragment" data-fragment-index="2" -->

    ```cpp
    :]
    ```
    <!-- .element: class="fragment" data-fragment-index="3" -->

    ---

    ```cpp
    static_assert(
      typeid(^T) ==           // type-erased AST info
      typeid(std::meta::info) // #header-meta-synopsis
    );
    ```
    <!-- .element: class="fragment" data-fragment-index="4" -->

    ```cpp
    static_assert(
      typeid(typename [: ^int :]) == typeid(int)
    );
    ```
    <!-- .element: class="fragment" data-fragment-index="5" -->

----

### P2996 / meta-programming

#### Possible in C++17* (https://github.com/boost-ext/mp)
<!-- .element: class="fragment" data-fragment-index="1" -->

----

##### P2996 / meta-programming (https://godbolt.org/z/43Yf8G8xz)

```cpp
template<size_t N, class... Ts>
using at =
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  typename [: // splicer (reify)
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
    std::array{^Ts...}[N] // lift into std::array{std::meta::info}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  :];
```
<!-- .element: class="fragment" data-fragment-index="2" -->

---

```cpp
static_assert(typeid(int)   == typeid(at<0, int, float, short>));
static_assert(typeid(float) == typeid(at<1, int, float, short>));
static_assert(typeid(short) == typeid(at<2, int, float, short>));
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

##### P1858 / C++26 - Generalized pack declaration and usage (https://wg21.link/P2996)
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
template<size_t N, class... Ts>
using at = Ts...[N];
```
<!-- .element: class="fragment" data-fragment-index="4" -->


----

##### P2996 / meta-programming (https://godbolt.org/z/43Yf8G8xz)

```cpp
template<class...> struct type_list { };
```
<!-- .element: class="fragment" data-fragment-index="0" -->


```cpp
template<class... Ts>
auto reverse_drop = [] {
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  std::array input{^Ts...};
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  std::vector<std::meta::info> result{};
  for (int i = input.size()-2/*skip 1*/; i >= 0; --i) { // fuse
    result.push_back(input[i]);
  }
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
  return std::meta::substitute(^type_list, result); // not instantiated
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
};
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
template<class... Ts>
using reverse_drop_t = typename [: reverse_drop<Ts...>() :];
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
static_assert(typeid(reverse_drop_t<int, float, short>) ==
              typeid(type_list<float, int>));
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

##### P2296 + ranges / meta-programming (https://godbolt.org/z/Y7edbe63c)

```cpp
template<class... Ts>
using reverse_drop_t = typename [:
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
    std::meta::substitute(^type_list,
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
        std::array{^Ts...} // std::array{meta::info}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
      | std::views::reverse // stl.ranges
      | std::views::drop(1)
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
    )
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
:];
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
static_assert(typeid(reverse_drop_t<int, float, short>) ==
              typeid(type_list<float, int>));
```
<!-- .element: class="fragment" data-fragment-index="0" -->

##### `filter/transform/...` require more effort but it's possible
<!-- .element: class="fragment" data-fragment-index="3" -->

----

#### Compilation-times? (https://boost-ext.github.io/mp)

<a href="https://boost-ext.github.io/mp"><img src="images/bench.png" style="width: 100%; background:none; border:none; box-shadow:none;" /></a>
<!-- .element: class="fragment" data-fragment-index="0" -->

##### ***Currently a few times slower than boost.mp11
<!-- .element: class="fragment" data-fragment-index="1" -->

----

### P2996 / introspection

#### [With limitations] possible in C++17

----

#### P2996 / introspection (https://godbolt.org/z/nonjcKxx1)

```cpp
template<class T> auto log(const T& t) {
  template for (constexpr auto m : // Expansion statements*
    std::meta::nonstatic_data_members_of(^T)) {
    std::print("{}={}\n", std::meta::name_of(m), t.[:m:]);
                                      //           ^
                                      //           |
                                      //   member-access splice
  }
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
int main() {
  struct foo { int a; int b; };
  log(foo{.a = 4, .b = 2});
  // a:4
  // b:2
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
// constexpr trace (https://wg21.link/P0596)
std::__report_constexpr_value(std::meta::name_of(m));
```
<!-- .element: class="fragment" data-fragment-index="2" -->

##### Expansion statements* (https://wg21.link/P1306)
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### C++20 / design by introspection (https://godbolt.org/z/Y8xPGxaaa)

```cpp
auto cpp20 = [](auto t) {
  if constexpr (requires { t.value; }) {
    return t.value;
  } else {
    return 0;
  }
};
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
struct foo { int value; };
struct bar { };

static_assert(42 == cpp20(foo{.value = 42}));
static_assert(0  == cpp20(bar{}));
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### P2996 / design by introspection (https://godbolt.org/z/Y8xPGxaaa)

```cpp
auto p2996 = []<class T>(T t) {
  if constexpr (
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
    // if any of non-static members name == "value"
    std::ranges::any_of(
      std::meta::nonstatic_data_members_of(^T),
      [](auto member) { return std::meta::name_of(member) == "value"; }
    )
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  ) {
    return t.value;
  } else {
    return 0;
  }
};
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
struct foo { int value; };
struct bar { };

static_assert(42 == p2996(foo{.value = 42}));
static_assert(0  == p2996(bar{}));
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

### P2996 / injection

----

#### P2996 / injection (https://godbolt.org/z/bKGqzo6fT)

```cpp
struct unpacked {
  short s;
  int i;
  bool b;
};
static_assert(12 == sizeof(unpacked));
```
<!-- .element: class="fragment" -->

---

```cpp
struct packed {
  int i;
  short s;
  bool b;
};
static_assert(8 == sizeof(packed));
```
<!-- .element: class="fragment" -->

----

#### P2996 / injection (https://godbolt.org/z/o39Kh6z7b)

```
template<class> struct packed; // to be injected with members
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
template<class T> consteval auto pack() {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  auto members = std::meta::nonstatic_data_members_of(^T);

  std::ranges::sort(members, [](auto lhs, auto rhs) {
    return std::meta::size_of(lhs) < std::meta::size_of(rhs);
  });
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  return std::meta::define_class(^packed<T>, members);
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
}

template<class T> using pack_t = typename [: pack<T>() :];
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
static_assert(8 == sizeof(pack_t<unpacked>));
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
static_assert(requires(pack_t<unpacked> p) { p.i; p.s; p.b; });
static_assert(typeid(pack_t<unpacked>) == typeid(packed<unpacked>));
```
<!-- .element: class="fragment" data-fragment-index="4" -->

----

### P2996 / injection (stateful meta-programming)

- #### compile-time counter
<!-- .element: class="fragment" -->
- #### borrow-checker
<!-- .element: class="fragment" -->
- #### destructive move
<!-- .element: class="fragment" -->
- #### type-safe any
<!-- .element: class="fragment" -->
- #### ...
<!-- .element: class="fragment" -->

----

#### P2996 / injection / global type_list (https://godbolt.org/z/d7GrW1j76)

```cpp
int main() {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  static_assert(typeid(get_list_t<>) == typeid(type_list<>));
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
  append_t<int>();
  static_assert(typeid(get_list_t<>) == typeid(type_list<int>));
```
<!-- .element: class="fragment" data-fragment-index="2" -->

---

```cpp
  if (false) {
    if constexpr (false) {
      assert([] { throw; return false; }());

      append_t<float>(); // ???
    }
  }
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
  static_assert(typeid(get_list_t<>) == typeid(type_list<int, float>));
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### P2996 / injection / global type_list (https://godbolt.org/z/d7GrW1j76)

```cpp
template<auto> struct type_list_impl; // needs versioning
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
consteval auto append(auto member) {
  for (auto i = 0;; ++i) { // infinite loop
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
    if (auto m = substitute(^type_list_impl, {reflect_value(i)});
        is_incomplete_type(m)) {            // not complete yet
      std::vector new_members = /* ... */;  // members... + member
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
     return define_class(substitute(^type_list_impl,{reflect_value(i)}),
                         new_members);
```
<!-- .element: class="fragment" data-fragment-index="5" -->

```cpp
    }
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
  }
}
```
<!-- .element: class="fragment" data-fragment-index="3" -->

---

```cpp
template<class T> using append_t = typename [: append(^T) :];
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
template<auto = []{}> // force evaluation to avoid memoization
using get_list_t = typename [: get_list(^type_list) :];
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### P2996 / run-time


#### Based on `examples` from the proposal
<!-- .element: class="fragment" -->

----

#### P2996 / run-time (https://godbolt.org/z/Eqffvn4dz)

```cpp
template<class E> requires std::is_enum_v<E>
constexpr auto enum_to_string(E value) -> std::string {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  std::string name{};
  template for (constexpr auto e : std::meta::enumerators_of(^E)) {
    if (value == [:e:]) {
      name = std::meta::name_of(e); // can't early exit
    }
  }
  return name;
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
enum E { A, B };

static_assert("A" == enum_to_string(E::A));
static_assert("B" == enum_to_string(E::B));
static_assert(""  == enum_to_string(E(42));
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### P2996 / run-time (https://godbolt.org/z/Eqffvn4dz)

```cpp
template auto enum_to_string(E) -> std::string; // x86-64 -O3
```
<!-- .element: class="fragment" -->

<img src="images/enum.png" style="width: 16%; background:none; border:none; box-shadow:none;" />
<!-- .element: class="fragment" -->

- #### Alternatives
<!-- .element: class="fragment" -->

  - #### jump-table
  <!-- .element: class="fragment" -->

  - #### switch-case (based on compiler heurstics)
  <!-- .element: class="fragment" -->

  - #### perfect hashing
  <!-- .element: class="fragment" -->

  - #### ...
  <!-- .element: class="fragment" -->

----

#### P2996 / run-time / switch-case* (https://godbolt.org/z/8reMEx3Yq)

```cpp
template<class E> requires std::is_enum_v<E>
constexpr auto enum_to_string(E value) -> std::string_view {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  return [&]<size_t I = 0>(this auto&& fn) { // C++23 deducing this
    constexpr auto enumerators = std::meta::enumerators_of(^E);
    constexpr auto size = std::size(enumerators);
  ```
<!-- .element: class="fragment" data-fragment-index="2" -->

  ```cpp
    switch (value) { // nested switch
      default:       // P2996 doesn't support code generation
        if constexpr (I < std::size(enumerators) - 1) {
          return fn.template operator()<I+1>();
        } else {
          return "";
        }

      case [: enumerators[I] :]:
        return std::meta::name_of(enumerators[I]);
    }
  ```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
  }();
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### P2996 / run-time / switch-case (https://godbolt.org/z/8reMEx3Yq)

```cpp
template auto enum_to_string(E) -> std::string_view; // x86-64 -O3
```
<!-- .element: class="fragment" -->

```cpp
enum_to_string(E): // decision-tree for enum E
  cmp     edi, 1
  lea     rax, [rip + .L.str.2]
  lea     rcx, [rip + .L.str.1]
  cmove   rcx, rax
  test    edi, edi
  lea     rax, [rip + .L.str]
  cmovne  rax, rcx
  xor     edx, edx
  cmp     edi, 2
  setb    dl
  ret

.L.str:   .asciz  "A"
.L.str.2: .asciz  "B"
.L.str.1: .zero   1
```
<!-- .element: class="fragment" -->

----

#### P2996 / run-time / perfect-hashing (https://godbolt.org/z/fa8hv3TTj)

```cpp
template auto enum_to_string(E) -> nonstd::string_view;
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
enum_to_string(E):        // x86-64 -O3
  movl $519, %eax         // pre-computed at compile-time mask
  pext %eax, %edi, %edi   // bit manipulation instruction set (BMI2) / 3 cycles
  movz buffer(%rdi), %edx // buffer
  ret
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```
buffer:
  .string  "\1A\1B"       // size|name...
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### Summary

* #### Static reflection
<!-- .element: class="fragment" -->

  * #### 👍
  <!-- .element: class="fragment" -->

    * #### Powerful proposal and possible C++26 inclusion!
<!-- .element: class="fragment" -->

  * #### 🤔
  <!-- .element: class="fragment" -->

    * #### API (std::meta::info, syntax, complexity?)
    <!-- .element: class="fragment" -->

    * #### Compilation-times (consteval + ranges?)
    <!-- .element: class="fragment" -->

    * #### Run-time performance (future considerations)
    <!-- .element: class="fragment" -->

----

### Let's embrace compile-time reflection!

<img src="images/qr.png" style="width: 15%; background:none; border:none; box-shadow:none;" />

---

###### [kris@jusiak.net](mailto:kris@jusiak.net) | [@krisjusiak](https://twitter.com/krisjusiak) | [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)

----

#### C23 / introspection - #embed (https://godbolt.org/z/e5Kq61jjP)

```cpp
struct foo { };
struct bar { };
void fn();
```
<!-- .element: class="fragment" -->

---

```cpp
static_assert(not meta_contains<"struct x">);
static_assert(meta_contains<"struct foo">);
static_assert(meta_contains<"struct bar">);
static_assert(meta_contains<"void fn()">);
```
<!-- .element: class="fragment" -->

---

```cpp
template<fixed_string Name>
constexpr auto meta_contains = [] {
  // #embed is C23 (https://wg21.link/P1967) and not C++23
  static constexpr char self[] = { #embed __FILE__ };
  const auto code = std::string_view(std::data(self), std::size(self));
  const auto find = code.find(Name);
  return find != std::string_view::npos and code[find-1] != '\"';
}();
```
<!-- .element: class="fragment" -->
          </script>
        </section>

      </div>
    </div>

    <script src="reveal.js/lib/js/head.min.js"></script>
    <script src="reveal.js/js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({

        // Display controls in the bottom right corner
        controls: false,

        // Display a presentation progress bar
        progress: false,

        // Display the page number of the current slide
        slideNumber: 'c/t',

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // Hides the address bar on mobile devices
        hideAddressBar: true,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style
        transition: 'none', // none/fade/slide/convex/concave/zoom

        // Transition speed
        transitionSpeed: 'default', // default/fast/slow

        // Transition style for full page slide backgrounds
        backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Parallax background image
        parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // Parallax background size
        parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

        // Number of pixels to move the parallax background per slide
        // - Calculated automatically unless specified
        // - Set to 0 to disable movement along an axis
        parallaxBackgroundHorizontal: null,
        parallaxBackgroundVertical: null,

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true },
          { src: 'extensions/plugin/line-numbers/line-numbers.js' }
        ]
      });

      <!--window.addEventListener("mousedown", handleClick, false);-->
      <!--window.addEventListener("contextmenu", function(e) { e.preventDefault(); }, false);-->

      function handleClick(e) {
        if (1 >= outerHeight - innerHeight) {
          document.querySelector( '.reveal' ).style.cursor = 'none';
        } else {
          document.querySelector( '.reveal' ).style.cursor = '';
        }

        e.preventDefault();
        if(e.button === 0) Reveal.next();
        if(e.button === 2) Reveal.prev();
      }
    </script>

  </body>
</html>
