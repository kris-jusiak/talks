<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Run-time optimizations for compile-time reflection</title>

    <link rel="stylesheet" href="reveal.js/css/reveal.css">
    <link rel="stylesheet" href="reveal.js/css/theme/league.css" id="theme">
    <link rel="stylesheet" href="extensions/plugin/line-numbers/line-numbers.css">
    <link rel="stylesheet" href="extensions/css/highlight-styles/zenburn.css">
    <link rel="stylesheet" href="extensions/css/custom.css">

    <style>
      .reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5 { text-transform: none; }
    </style>

    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );

      function set_address(self, remote, local) {
        if (window.location.search.match("local")) {
          self.href = local;
        } else {
          self.href = remote;
        }
      }
    </script>

    <meta name="description" content="Compile-time reflections">
    <meta name="author" content="Kris Jusiak">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
          <script type="text/template">
          </script>
          </section>

          <section data-markdown=""
                   data-separator="^====+$"
                   data-separator-vertical="^----+$">
          <script type="text/template">
<!-- .element: data-background-image="images/cpponsea.png"  data-background-size="100%"  -->

<br />&nbsp;
<br />&nbsp;
<br />&nbsp;
<br />&nbsp;
<br />&nbsp;
<br />&nbsp;
<br />&nbsp;
<img src="images/qr.png" style="width: 15%; background:none; border:none; box-shadow:none;" />

##### [kris@jusiak.net](mailto:kris@jusiak.net) | [@krisjusiak](https://twitter.com/krisjusiak) | [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)

----

#### Agenda

- #### Reflection
<!-- .element: class="fragment" -->

    - #### Introspection
    <!-- .element: class="fragment" -->

    - #### Meta-Programming
    <!-- .element: class="fragment" -->

- #### [Performance] Case study
<!-- .element: class="fragment" -->

    - ##### enum_to_string
    <!-- .element: class="fragment" -->

    - ##### string_to_enum
    <!-- .element: class="fragment" -->

- #### Summary
<!-- .element: class="fragment" -->

----

#### Disclaimer

- ##### Proposal based
<!-- .element: class="fragment" -->

- ##### x86-64 focused
<!-- .element: class="fragment" -->

    - ##### https://github.com/bloomberg/clang-p2996
    <!-- .element: class="fragment" -->

- ##### C++20
<!-- .element: class="fragment" -->

  - ##### https://github.com/boost-ext
  <!-- .element: class="fragment" -->

----

#### Reflection for C++26 - https://wg21.link/P2996

- ##### Static (compile-time)
<!-- .element: class="fragment" data-fragment-index="0" -->

- ##### Value/consteval based
<!-- .element: class="fragment" data-fragment-index="1" -->

- ##### Supports Introspection/Meta-Programming
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### P2996 - Introspection

```cpp
namespace std::meta {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  // #member-queries
  consteval auto enumerators_of(info) -> vector<info>;
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  // #name and location
  consteval auto name_of(info) -> string_view;
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  // ...
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
using info = decltype(^::); // type-erased AST info
```
<!-- .element: class="fragment" data-fragment-index="4" -->

----

#### P2996 - Meta-Programming

```cpp
[: // splicer (reify)
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
  ^T // lift (reflexpr)
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
:]
```
<!-- .element: class="fragment" data-fragment-index="3" -->

---

```cpp
static_assert(
  typeid(^T) == typeid(meta::info)
);
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
static_assert(
  typeid(typename[:^int:]) == typeid(int)
);
```
<!-- .element: class="fragment" data-fragment-index="5" -->


----

##### P2996 / Meta-Programming (https://godbolt.org/z/43Yf8G8xz)

```cpp
template<size_t N, class... Ts>
using at =
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  typename [: // splicer (reify)
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
    array{^Ts...}[N] // lift into array{meta::info}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  :];
```
<!-- .element: class="fragment" data-fragment-index="2" -->

---

```cpp
static_assert(typeid(int)   == typeid(at<0, int, float, short>));
static_assert(typeid(float) == typeid(at<1, int, float, short>));
static_assert(typeid(short) == typeid(at<2, int, float, short>));
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

##### C++26 - Generalized pack declaration and usage (https://wg21.link/P1858)
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
template<size_t N, class... Ts>
using at = Ts...[N];
```
<!-- .element: class="fragment" data-fragment-index="4" -->


----

##### P2996 + ranges / Meta-Programming (https://godbolt.org/z/Y7edbe63c)

```cpp
template<class...> struct type_list{ };
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
template<class... Ts>
using reverse_drop_t = typename [:
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
    meta::substitute(^type_list,
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
        array{^Ts...} // array{meta::info}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
      | views::reverse
      | views::drop(1)
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
    )
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
:];
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
static_assert(typeid(reverse_drop_t<int, float, short>) ==
              typeid(type_list<float, int>));
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

##### P2996 - Meta-Programming / compilation times - https://boost-ext.github.io/mp

<a href="https://boost-ext.github.io/mp"><img src="images/bench.png" style="width: 100%; background:none; border:none; box-shadow:none;" /></a>

##### Possible since C++17 (msvc, gcc, clang) - https://github.com/boost-ext/mp
<!-- .element: class="fragment" data-fragment-index="0" -->

----

### [Performance] Case study

- #### LLVM Machine Code Analyzer - https://llvm.org/llvm-mca.html
<!-- .element: class="fragment" data-fragment-index="0" -->

- #### Instruction Tables - https://www.agner.org/optimize/instruction_tables.pdf
<!-- .element: class="fragment" data-fragment-index="1" -->

<img src="images/latencies.png" style="width: 50%; background:white; border:none; box-shadow:none;" />
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### enum_to_string

<img src="images/enum_to_string.png" style="width: 100%; background:none; border:none; box-shadow:none;" />
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### Enum - https://eel.is/c++draft/dcl.enum

#### Unscoped Enum (C-style Enum)
<!-- .element: class="fragment" style="float:left" -->
<br />

```cpp
enum color { red, green, blue, };
```
<!-- .element: class="fragment" -->

---

#### Scoped Enum (C++11)
<!-- .element: class="fragment" style="float:left" -->
<br />

```cpp
enum class http_status_code : uint32_t {
  ok = 200, not_found = 404, bad_gateway = 502,
};
```
<!-- .element: class="fragment" -->

---

#### 'Flag' Enum (not a standard term)
<!-- .element: class="fragment" style="float:left" -->
<br />

```cpp
enum class permissions : uint8_t {
  read     = (1 << 0), // 0b00000001
  write    = (1 << 1), // 0b00000010
  execute  = (1 << 2), // 0b00000100
};
```
<!-- .element: class="fragment" -->

----

#### enum_to_string - how hard it can be?

```cpp
enum { A = 1, B = 1, };
```
<!-- .element: class="fragment" -->

```cpp
enum_to_string(A); // ?
enum_to_string(B); // ?
```
<!-- .element: class="fragment" -->

---

```cpp
enum flag_enum { A = 0b01, B = 0b10, };
```
<!-- .element: class="fragment" -->

```cpp
enum_to_string(A | B); // ?
```
<!-- .element: class="fragment" -->

---

```cpp
enum E { A };
```
<!-- .element: class="fragment" -->

```cpp
enum_to_string(static_cast<E>(42)); // ?
```
<!-- .element: class="fragment" -->

----

#### enum_to_string - P2996 - https://godbolt.org/z/fo58vedxj

```
template<class E> requires is_enum_v<E>
constexpr auto enum_to_string(E value) -> string_view {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  template for (constexpr auto e : meta::enumerators_of(^E)) {
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
    if (value == [:e:]) {
      return meta::name_of(e);
    }
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
  }
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  return {};
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

##### Expansion statements* (https://wg21.link/P1306)
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### enum_to_string - P2996 - https://godbolt.org/z/fo58vedxj

```cpp
enum color { red, green, blue, };
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
template<class E> requires is_enum_v<E>
constexpr auto enum_to_string(E value) -> string_view {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  if (value == color::red)   { return "red";   }
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  if (value == color::green) { return "green"; }
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
  if (value == color::blue)  { return "blue";  }
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
  return {};
```
<!-- .element: class="fragment" data-fragment-index="5" -->

```
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

##### 'break' is not supported with 'template for'
<!-- .element: class="fragment" data-fragment-index="6" -->

----

#### enum_to_string - P2996 - https://godbolt.org/z/fo58vedxj

```cpp
[1]: #uOps    [2]: Latency   [3]: RThroughput
[4]: MayLoad  [5]: MayStore  [6]: HasSideEffects (U)
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

<pre><code class="fragment" data-trim data-noescape data-fragment-index="1" data-line-numbers="2,3,4,5">
[1] [2] [3]  [4] [5] [6]  Instructions:
 1   1  0.25              test edi, edi
 1   1  0.50              je   .LBB0_1
 1   1  0.25              cmp  edi, 1
 1   1  0.50              jne  .LBB0_4
 1   1  0.50              mov  eax, 5
 1   1  0.33              lea  rdx, [rip + .L.str.1]
 1   5  0.50          U   ret
 1   1  0.50              mov  eax, 3
 1   1  0.33              lea  rdx, [rip + .L.str]
 1   5  0.50          U   ret
 1   1  0.50              mov  eax, 4
 1   1  0.33              lea  rdx, [rip + .L.str.2]
 1   5  0.50          U   ret
</code></pre>

```cpp
.L.str:   "green"
.L.str.1: "red"
.L.str.2: "blue"
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### switch-case

##### lowering strategies - https://github.com/gcc-mirror/gcc/blob/master/gcc/tree-switch-conversion.cc
<!-- .element: class="fragment" style="float:left" -->
<br />

##### bitset (gcc)
<!-- .element: class="fragment" style="float:left" -->
```cpp
auto bit_test_cluster::is_beneficial(auto count, auto uniq) {
  // count: number of cases, uniq: number of distinct values
  return (uniq==1 && count>=3) || (uniq==2 && count>=5) ||
         (uniq==3 && count>=6);
}
```
<!-- .element: class="fragment" -->

##### jump-table<br />(gcc/clang)
<!-- .element: class="fragment" style="float:left" -->

```cpp
auto jump_table_cluster::can_be_handled(auto cmp_count) {
  return get_range(get_low(), get_high()) <=
    (optimize_for_size() ? 2 : 8) * cmp_count;
}

auto jump_table_cluster::is_beneficial(auto start, auto end) {
  return end - start + 1 >= 5;
}
```
<!-- .element: class="fragment" -->

##### decision<br />tree<br />(gcc/clang)
<!-- .element: class="fragment" style="float:left" -->

```cpp

otherwise // __builtin_expect_with_probability



```
<!-- .element: class="fragment" -->

----

#### Helper utilities with P2996

```cpp
template<class E> requires is_enum_v<E>
inline constexpr auto enumerators =
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  []<size_t... Ns>(index_sequence<Ns...>) {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
    return array{
      pair{
        [: meta::enumerators_of(^E)[Ns] :],
        meta::name_of(meta::enumerators_of(^E)[Ns])
      }...
    };
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```
}(make_index_sequence<meta::enumerators_of(^E).size()>{});
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### Helper utilities with P2996

```cpp
enum color { red, green, blue, };
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
static_assert(
  enumerators<color>
  ==
  array{
    pair{color::red,   "red"   },
    pair{color::green, "green" },
    pair{color::blue,  "blue"  },
  }
);
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### switch-case - https://godbolt.org/z/Mc5Yvsrxc

```cpp
template<class E> requires is_enum_v<E>
constexpr auto enum_to_string(E value) {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  return [value]<size_t I = 0>(this auto&& self) -> string_view {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
    if constexpr (I == enumerators<E>.size()) {
      return {};
    } else {
```
<!-- .element: class="fragment" data-fragment-index="2" -->
```cpp
      switch (value) {
        default:
          return self.template operator()<I + 1>();

        case enumerators<E>[I].first:
          return enumerators<E>[I].second;
      }
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
    }
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  }();
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### switch-case - https://godbolt.org/z/E5en4K8qn

```cpp
enum class http_status_code : uint32_t {
  ok         = 200,  // first cluster
  created    = 201,
  accepted   = 202,
  no_content = 204,
  im_used    = 226,  // odd value
  forbidden  = 403,  // second cluster
  not_found  = 404,
};
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### switch-case - https://godbolt.org/z/E5en4K8qn

```cpp
[1]: #uOps [2]: Latency [3]: RThroughput [4]: MayLoad [5]: MayStore
```
<!-- .element: class="fragment" data-fragment-index="0" -->

<pre><code class="fragment" data-trim data-noescape data-fragment-index="1" data-line-numbers="1,6,9,13">
[1] [2] [3]  [4] [5] [6]  Instructions:
 1   1  0.33              lea eax, [rdi - 200] /*jump-table offset*/
 1   1  0.25              cmp eax, 5
 1   1  0.50              jae .LBB0_1
 1   1  0.50              mov ecx, 23
 1   1  0.50              bt  ecx, eax /*bitset*/
 1   1  0.50              jae .LBB0_1
 1   0  0.17              mov eax, eax
 1   1  0.33              lea rcx,[rip+.Lswitch.table] /*jump-table*/
 1   5  0.33  *           movsxd rax, dword ptr [rcx + 4*rax]
 1   5  0.50          U   ret
 1   0  0.17              xor eax, eax
 1   1  0.25              cmp edi, 226 /*decision-tree*/
 1   1  0.33              lea rax, [rip + .L.str.4]
 1   1  0.50              cmovne rax, rcx
 1   5  0.50          U   ret
</code></pre>

```cpp
.Lswitch.table:               .asciz  "accepted"    /*202*/
  .asciz  "ok"       /*200*/  .asciz  ""
  .asciz  "created"  /*201*/  .asciz  "no_content"  /*204*/
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### Code Injection with Token Sequences - https://wg21.link/P3294

----

#### Want performance? Know your hardware!

----

#### Single Instruction, Multiple Data - SIMD

<img src="images/simd.png" style="width: 80%; background:white; border:none; box-shadow:none;" />
<!-- .element: class="fragment" data-fragment-index="0" -->

#### std::simd - https://wg21.link/P1928
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### std::simd (x86)

##### x86.sse (128 bits)
<!-- .element: class="fragment" data-fragment-index="0" style="float:left" -->
<br />

```cpp
static_assert(4u  == simd_size_v<uint32_t, simd_abi::native<uint32_t>>);
```
<!-- .element: class="fragment" data-fragment-index="0" -->

##### x86.avx (256 bits)
<br />
<!-- .element: class="fragment" data-fragment-index="1" style="float:left" -->

```cpp
static_assert(8u  == simd_size_v<uint32_t, simd_abi::native<uint32_t>>);
```
<!-- .element: class="fragment" data-fragment-index="1" -->

##### x86.avx512 (512 bits)
<br />
<!-- .element: class="fragment" data-fragment-index="2" style="float:left" -->

```cpp
static_assert(16u == simd_size_v<uint32_t, simd_abi::native<uint32_t>>);
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### std::simd - https://godbolt.org/z/9c44jGnW6

```cpp
template<class E, class T = underlying_type_t<E>>
  requires (is_enum_v<E> and enumerators<E>.size() <=
                             simd_size_v<T, simd_abi::native<T>>)
constexpr auto enum_to_string(E value) -> string_view {
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
  simd<T, enumerators<E>.size()> lhs{value};
  simd<T, enumerators<E>.size()> rhs{&keys[i], element_aligned}
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
  const auto match = lhs == rhs; // element-wise compound comparison
```
<!-- .element: class="fragment" data-fragment-index="5" -->

```cpp
  return any_of(match) ? values[find_first_set(match)] : {};
```
<!-- .element: class="fragment" data-fragment-index="6" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="3" -->

---

```cpp
std::array<E, enumerators<E>.size()> keys{};
std::array<string_view, enumerators<E>.size()> values{};
```
<!-- .element: class="fragment" data-fragment-index="4" -->

----

#### std::simd - https://godbolt.org/z/9c44jGnW6

```cpp
[1]: #uOps    [2]: Latency   [3]: RThroughput
[4]: MayLoad  [5]: MayStore  [6]: HasSideEffects (U)
```
<!-- .element: class="fragment" data-fragment-index="0" -->

<pre><code class="fragment" data-trim data-noescape data-fragment-index="1" data-line-numbers="4,5,6,8">
[1] [2] [3]  [4] [5] [6]  Instructions:
 1   1  1.00              vmovd xmm1, edi
 1   0  0.17              xor edx, edx
 1   1  0.50              vpbroadcastd  xmm0, xmm1 /*lhs*/
 1   8  0.50  *           vpcmpeqd xmm0, xmm0, xmmword ptr[rip+.keys]
 1   1  1.00              vmovmskps eax, xmm0
 1   1  0.25              movzx eax, al
 6   3  3.00              rep bsf eax, eax /*bit scan forward*/
 1   1  0.50              shl rax, 4
 1   5  0.33  *           mov rdx, qword ptr [rax + value+8]
 1   5  0.50          U   ret
</code></pre>

```cpp
keys:        values:
  .long 0      .quad "red"
  .long 1      .quad "green"
  .long 2      .quad "blue"
  .long 0      .quad ""
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### Want performance? Know your data!

----

##### Perfect hashing - https://en.wikipedia.org/wiki/Perfect_hash_function

<img src="images/hashing.png" style="width: 75%; background:white; border:none; box-shadow:none;" />
<!-- .element: class="fragment" data-fragment-index="0" -->

-----

#### Perfect hashing

<table><tr><td>
<a href="https://link.springer.com/chapter/10.1007/978-3-642-04128-0_61"><img src="images/hdc.png" style="width: 100%; background:none; border:none; box-shadow:none;" /></a>
</td>
<td>
<a href="https://arxiv.org/pdf/2104.10402"><img src="images/pthash.png" style="width: 100%; background:none; border:none; box-shadow:none;" /></a>
</td>
<td>
<a href="https://github.com/serge-sans-paille/frozen"><img src="images/phash.png" style="width: 100%; background:none; border:none; box-shadow:none;" /></a>
</td>
</tr></table>

##### 'cmph/pthash' can handle large sizes (> 1'000'000)
<!-- .element: class="fragment" data-fragment-index="0" -->

-----

#### Hardware accelerated perfect hashing

<table><tr>
<td><pre><code class="fragment" data-trim data-noescape data-fragment-index="1">
05266
11147
55460
29060
56063
30018
10154
59700
14740
41928
01030
47631
</code></pre></td>
<td><pre><code class="fragment" data-trim data-noescape data-fragment-index="2">
0 0 0 1 0 1 0 0 1 0 [0] [1] 0 [0] [1] [0]
0 0 1 0 1 0 1 1 1 0 [0] [0] 1 [0] [1] [1]
1 1 0 1 1 0 0 0 1 0 [1] [0] 0 [1] [0] [0]
0 1 1 1 0 0 0 1 1 0 [0] [0] 0 [1] [0] [0]
1 1 0 1 1 0 1 0 1 1 [1] [1] 1 [1] [1] [1]
0 1 1 1 0 1 0 1 0 1 [0] [0] 0 [0] [1] [0]
0 0 1 0 0 1 1 1 1 0 [1] [0] 1 [0] [1] [0]
1 1 1 0 1 0 0 1 0 0 [1] [1] 0 [1] [0] [0]
0 0 1 1 1 0 0 1 1 0 [0] [1] 0 [1] [0] [0]
1 0 1 0 0 0 1 1 1 1 [0] [0] 1 [0] [0] [0]
0 0 0 0 0 1 0 0 0 0 [0] [0] 0 [1] [1] [0]
1 0 1 1 1 0 1 0 0 0 [0] [0] 1 [1] [1] [1]
</code></pre></td>
<td><img class="fragment" data-fragment-index="4" src="images/perfect.png" style="width: 61%; background:none; border:none; box-shadow:none;" />
</td></tr>
<td>
<pre><code class="fragment" data-trim data-noescape data-fragment-index="3">
mask
</code></pre></td>
<td><pre><code class="fragment" data-trim data-noescape data-fragment-index="3">
0 0 0 0 0 0 0 0 0 0  1   1  0  1   1   1
</code></pre></td><td>
</td></tr>
</table>

-----

#### Hardware accelerated perfect hashing

<img src="images/pext.png" style="width: 100%; background:none; border:none; box-shadow:none;" />
<!-- .element: class="fragment" data-fragment-index="0" -->

###### https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=pext
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### Hardware accelerated perfect hashing

```cpp
template<class E> requires is_enum_v<E>
constexpr auto enum_to_string(E value) const -> string_view {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  static constexpr auto lookup = [] {
    array<pair<E, string_view>, (1u << std::popcount(mask))> lookup{};
    for (const auto& [k, v] : enumerators<E>) {
      lookup[pext(k, mask<E>)] = {k, v};
    }
    return lookup;
  }();
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  auto&& [rhs, result] = lookup[pext(value, mask<E>)];
  return value == rhs ? result : {};
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### Hardware accelerated perfect hashing - mask

```cpp
template<class E, class T = underlying_type_t<E>> requires is_enum_v<E>
consteval auto mask() {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  bitset<sizeof(T) * CHAR_BIT> mask(
    numeric_limits<T>::max() // 0b11111111111...
  );
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  #pragma omp parallel for // not possible at consteval
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
  for (auto i = 0u; i < mask.size(); ++i) {
    mask.flip(i);
    if (not unique(enumerators<E>, mask)) {
      mask.flip(i);
    }
  }
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  assert(is_unique(mask));
  return mask.to_ullong();
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

-----

#### Hardware accelerated perfect hashing - https://godbolt.org/z/j4E5Pcjx1

```cpp
[1]: #uOps    [2]: Latency   [3]: RThroughput
[4]: MayLoad  [5]: MayStore  [6]: HasSideEffects (U)
```
<!-- .element: class="fragment" data-fragment-index="0" -->


<pre><code class="fragment" data-trim data-noescape data-fragment-index="1" data-line-numbers="3, 6, 7, 8">
[1] [2] [3]  [4] [5] [6]  Instructions:
 1   0  0.17              mov   ecx, edi
 1   1  0.25              and   ecx, 3   /*pext*/
 1   1  0.50              shl   ecx, 4
 1   1  0.33              lea   rdx, [rip + lookup]
 1   0  0.17              xor   eax, eax /*unknown value*/
 1   5  0.33  *           cmp   dword ptr [rcx + rdx], edi
 1   5  0.50  *           cmove rax, qword ptr [rcx + rdx + 8]
 1   5  0.50          U   ret
</code></pre>

---

```cpp
lookup:
 .long 0 .quad "red"
 .long 1 .quad "green"
 .long 2 .quad "blue"
 .long 0 .quad ""
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### Potential improvement if the input can be guaranteed to be valid

```cpp
          assert(contains<enumerator<E>>(value)); // valid input
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### Hardware accelerated perfect hashing (unsafe) - https://godbolt.org/z/3hMxEoG5h

```cpp
template<class E> requires is_enum_v<E>
constexpr auto unsafe$enum_to_string(E value) -> string_view {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  [[assume(contains<enumerators<E>>(value)]];
  return lookup[pext(value, mask<E>)];
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### Hardware accelerated perfect hashing (unsafe) - https://godbolt.org/z/3hMxEoG5h

```cpp
[1]: #uOps    [2]: Latency   [3]: RThroughput
[4]: MayLoad  [5]: MayStore  [6]: HasSideEffects (U)
```
<!-- .element: class="fragment" data-fragment-index="0" -->


<pre><code class="fragment" data-trim data-noescape data-fragment-index="1" data-line-numbers="2,5">
[1] [2] [3]  [4] [5] [6]  Instructions:
 1   1  0.25              and edi, 3 /*pext*/
 1   1  0.25              shl edi, 4
 1   1  0.25              lea rax, [rip + lookup]
 1   4  0.50  *           mov rax, qword ptr [rdi + rax + 8]
 2   1  0.50          U   ret
</code></pre>

---

```cpp
lookup: // minimal
  .quad "red"
  .quad "green"
  .quad "blue"
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### No [BMI2](https://en.wikipedia.org/wiki/X86_Bit_manipulation_instruction_set)? Zen2? ARM?

<a href="https://uops.info/table.html?search=PEXT%20(R64%2C%20R64%2C%20R64)&cb_lat=on&cb_HSW=on&cb_BDW=on&cb_SKL=on&cb_RKL=on&cb_ZEN2=on&cb_ZEN3=on&cb_ZEN4=on&cb_measurements=on&cb_bmi=on"><img src="images/zen2.png" style="width: 100%; background:none; border:none; box-shadow:none;" /></a>
<!-- .element: class="fragment" data-fragment-index="0" -->

#### bmi2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<!-- .element: class="fragment" data-fragment-index="1" style="float:left" -->

```cpp
mov     ecx, 789
pext    ecx, eax, ecx
```
<!-- .element: class="fragment" data-fragment-index="2" -->

#### no bmi2&nbsp;&nbsp;
<!-- .element: class="fragment" data-fragment-index="3" style="float:left" -->

```cpp
mov     ecx, eax
and     ecx, 789
imul    ecx, ecx, 57
shr     ecx, 2
and     ecx, 248
```
<!-- .element: class="fragment" data-fragment-index="4" -->

---

##### <a href="https://schedule.cppnow.org/session/2024/a-case-study-in-zero-cost-abstractions-high-performance-message-dispatch/">C++Now 2024 - Luke Valenty: A case study in zero-cost abstractions: High performance message dispatch</a>
<!-- .element: class="fragment" data-fragment-index="5" -->

----

#### What about 'Flag' enum?

```cpp
enum class permissions : uint8_t {
  read     = (1 << 0), // 0b001
  write    = (1 << 1), // 0b010
  execute  = (1 << 2), // 0b100
  // ----------------------------//
  // mask  :              0b111  // size: 2**(popcount(mask))
  // ----------------------------//
};
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### enum_to_string - 'Flag' enum - https://godbolt.org/z/MMd9K6xz4

```cpp
template<class E>
concept FlagEnum = is_enum_v<E> and [] {
  for (const auto& enumeration : meta::enumerators_of(^E)) {
    if (not has_single_bit(to_underlying(enumeration))) {
      return false;
    }
  }
  return true;
}();
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
enum class f1 : uint8_t { a = 0b00, b = 0b01, c = 0b10, };
enum class f2 : uint8_t { a = 0b00, b = 0b01, c = 0b11, };

static_assert(    FlagEnum<f1>);
static_assert(not FlagEnum<f2>);
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### enum_to_string - 'Flag' enum - https://godbolt.org/z/MMd9K6xz4

```cpp
constexpr auto unsafe$enum_to_string(FlagEnum auto value) {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  static constexpr auto lookup = [] {
    array<string_view, enumerators<E>.size()> lookup{};
    for (auto i = 0u; const auto& [_, name] : enumerators<E>) {
      lookup[i++] = name;
    }
    return lookup;
  }();
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  [[assume(has_single_bit(to_underlying(value))]];
  return lookup[countr_zero(to_underlying(value))];
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
// countr_zero - count the number of trailing zero bits
0b000000100
        ^21 = 2
```
<!-- .element: class="fragment" data-fragment-index="3" -->

----

#### enum_to_string - 'Flag' enum - https://godbolt.org/z/4cc8MabjG

```cpp
[1]: #uOps    [2]: Latency   [3]: RThroughput
[4]: MayLoad  [5]: MayStore  [6]: HasSideEffects (U)
```
<!-- .element: class="fragment" data-fragment-index="0" -->

<pre><code class="fragment" data-trim data-noescape data-fragment-index="1" data-line-numbers="2,4">
[1] [2] [3]  [4] [5] [6]  Instructions:
 2   2  0.50              tzcnt eax, edi
 1   1  0.33              lea rcx, [rip + lookup]
 1   5  0.33  *           mov rax, qword ptr [rcx + 8*rax]
 1   5  0.50          U   ret
</code></pre>

---

```cpp
lookup: // minimal
  .quad "red"
  .quad "green"
  .quad "blue"
```
<!-- .element: class="fragment" data-fragment-index="2" -->

-----

#### enum_to_string (there is no sliver bullet)

```cpp
template<class E, class T = underlying_type_t<E>>
  requires (is_enum_v<E> and enumerators<E>.size() <=
                             simd_size_v<T, simd_abi::native<T>>)
constexpr auto enum_to_string(E value) -> string_view;
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
template<class E>
  requires (is_enum_v<E> and enumerators<E>.size() <= 64u)
constexpr auto enum_to_string(E value) -> string_view;
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
template<class E>
  requires (is_enum_v<E> and enumerators<E>.size() > 64u)
constexpr auto enum_to_string(E value) -> string_view;
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
template<class E> requires is_flag_enum_v<E>
constexpr auto enum_to_string(E value) -> string_view;
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
...
```
<!-- .element: class="fragment" data-fragment-index="5" -->

----

#### enum_to_string - benchmarks -
##### https://github.com/boost-ext/mph/blob/benchmark/enum_to_string/benchmark.ipynb

<img src="images/benchmark_enum_to_string.png" style="width: 70%; background:none; border:none; box-shadow:none;" />
<!-- .element: class="fragment" data-fragment-index="0" -->

##### Hardware accelerated perfect hashing + std::simd for size greater than 100
<!-- .element: class="fragment" data-fragment-index="1" -->

----

### [Performance] Case study

----

#### string_to_enum

<img src="images/string_to_enum.png" style="width: 100%; background:none; border:none; box-shadow:none;" />
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### string_to_enum - if/else - https://godbolt.org/z/Yha87c9f3

```cpp
template<class E> requires is_enum_v<E>
constexpr auto string_to_enum(string_view str) -> optional<E> {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  if (str == "red")   { return color::red;   }
  if (str == "green") { return color::green; }
  if (str == "blue")  { return color::blue;  }

  return nullopt;
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### string_to_enum - switch-case - https://godbolt.org/z/Yha87c9f3

```cpp
template<class E> requires is_enum_v<E>
constexpr auto string_to_enum(string_view str) -> optional<E> {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  switch (hash(str)) {
    case hash("red"):   return color::red;
    case hash("green"): return color::green;
    case hash("blue"):  return color::blue;
  }
  return nullopt;
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

##### hash can be std::bitcast* (explored later)
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### string_to_enum - trie - https://godbolt.org/z/Yha87c9f3

```cpp
enum color { red, green, blue, black };
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
template<class E> requires is_enum_v<E>
constexpr auto string_to_enum(string_view str) -> optional<E> {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  switch (str[0]) {
    case 'r': return color::red;
    case 'g': return color::green;
    case 'b': {
      switch (str[2]) { // or size
        case 'u': return color::blue;
        case 'a': return color::black;
      }
    }
  }
  return nullopt;
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### string_to_enum - map - https://godbolt.org/z/Yha87c9f3

```cpp
template<class E> requires is_enum_v<E>
constexpr auto string_to_enum(string_view str) {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  static const unordered_map<string_view, E> map{
    {"red",   color::red   },
    {"green", color::green },
    {"blue",  color::blue  },
  };
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  return map.at(str);
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

##### (constexpr frozen::unordered_map) https://github.com/serge-sans-paille/frozen
<!-- .element: class="fragment" data-fragment-index="3" -->

----

##### string_to_enum - gperf

<a href="https://www.gnu.org/software/gperf/"><img src="images/gperf.png" style="width: 40%; background:none; border:none; box-shadow:none;" /></a>
##### https://www.gnu.org/software/gperf (used by gcc, chrome, ...)
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Want performance?&nbsp;
<!-- .element:  data-fragment-index="0" style="float:left" -->

#### Know your hardware!&nbsp;
<!-- .element: class="fragment" data-fragment-index="1" style="float:left" -->

#### Know your data!
<!-- .element: class="fragment" data-fragment-index="2" style="float:left" -->

----

#### string to int - https://godbolt.org/z/GnKoK9vrj

```cpp
static_assert(3 + 1/*null termination*/ == sizeof("cpp"));
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```
int32_t        :  4 bytes
int64_t        :  8 bytes
simd<char, 16> : 16 bytes // x86.sse
simd<char, 32> : 32 bytes // x86.avx
simd<char, 64> : 64 bytes // x86.avx512
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

##### simd<char, N> can be used to implement optimized string
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### string to int - https://godbolt.org/z/GnKoK9vrj

```cpp
template<class T, size_t Size> requires (Size <= sizeof(T))
constexpr auto to(const char (&str)[Size]) -> T {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  T t{};
  memcpy(&t, str, Size); // optimized
  return t;
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
template<class T>
constexpr auto to(string_view str) -> T {
  T t{};
  assert(str.size() <= sizeof(T));
  memcpy(&t, str.data(), str.size()); // slow
  return t;
}
```
<!-- .element: class="fragment" data-fragment-index="3" -->

----

#### string to int - https://godbolt.org/z/GnKoK9vrj

```cpp
template<class T>
constexpr auto to(string_view str) -> T {
  T t;
  memcpy(&t, str.data(), sizeof(t)); // potentially unsafe
  return bzhi(t, str.size() * CHAR_BIT);
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

<table><tr><td>
<a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=bzhi"><img src="images/bzhi.png" style="width: 120%; background:none; border:none; box-shadow:none;" /></a>
</td><td>
<pre><code>sal  rdi, 3
bzhi eax, DWORD PTR [rsi], edi
ret

bzhi 3*8, "cpp....." ==
          "cpp\0\0\0\0\0"
</code></pre>
</td></tr></table>
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### string to int - https://godbolt.org/z/GnKoK9vrj

```cpp
template<class T, size_t PageSize = 4096u>
constexpr auto to(string_view str) {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  if ((uint64_t(str.data()) & (PageSize - 1ul)) >
      (PageSize - sizeof(T))) [[unlikely]] { // page boundary
    return [&str] [[gnu::cold]] {
      T t;
      memcpy(&t, str.data(), str.size()); // slow path
      return t;
    }();
  }
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  T t{};
  memcpy(&t, str.data(), sizeof(t)); // fast path
  return bzhi(t, str.size() * CHAR_BIT);
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

##### https://github.com/glibc/blob/master/sysdeps/generic/memcopy.h
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### string_to_enum - Hardware accelerated perfect hashing

```cpp
template<class E, class T = underlying_type_t<E>> requires is_enum_v<E>
constexpr auto string_to_enum(std::string_view str) -> E {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  static constexpr auto lookup = /* same as in enum_to_string */;
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  auto&& lhs = to<T>(str);
  auto&& [rhs, result] = lookup[pext(lhs, mask<E>)];
  return lhs == rhs ? result : {};
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

##### string_to_enum - Hardware accelerated perfect hashing - https://godbolt.org/z/1fqM5KEbP

```cpp
[1]: #uOps    [2]: Latency   [3]: RThroughput
[4]: MayLoad  [5]: MayStore  [6]: HasSideEffects (U)
```
<!-- .element: class="fragment" data-fragment-index="0" -->

<pre><code class="fragment" data-trim data-noescape data-fragment-index="1" data-line-numbers="3,5">
[1] [2] [3]  [4] [5] [6]  Instructions:
 1   1  0.50              shl   rdi, 3
 2   5  0.50  *           bzhi  rcx, qword ptr [rsi], rdi
 1   1  0.50              mov   eax, 17
 1   3  1.00              pext  edx, ecx, eax
 1   1  0.50              shl   edx, 4
 1   1  0.33              lea   rsi, [rip + find]
 1   0  0.17              xor   eax, eax
 1   5  0.33  *           cmp   rcx, qword ptr [rdx + rsi]
 1   5  0.50  *           cmove eax, dword ptr [rdx + rsi + 8]
 1   5  0.50          U   ret
</code></pre>

---

```cpp
find:
  .quad 1702194274  /*blue*/  .long 2
  .quad 47414754979 /*green*/ .long 1
  .quad 6579570     /*red*/   .long 0
  .quad 0                     .long 0
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### string_to_enum - Minimal perfect hashing

<img src="images/hashing.png" style="width: 75%; background:white; border:none; box-shadow:none;" />
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### string_to_enum - Minimal perfect hashing

```cpp
enum uri { ftp = 0, file = 1, http = 2, ws = 3, wss = 4, };
```
<!-- .element: class="fragment" style="float:left" data-fragment-index="0" -->

---

#### bit mixer
<!-- .element: class="fragment" style="float:left" data-fragment-index="1" -->
<br />

```cpp
(value * magic) >> shift
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
// shift
static_assert(
  (sizeof(u32) * CHAR_BIT) - countr_zero(max(&enumerators<E>::second))
  ==
  29 // 4 * 8 - 3
);
```
<!-- .element: class="fragment" data-fragment-index="3" -->

---

```cpp
// magic
assert((to<u32>("ftp")  * 2893426669) >> 29) == 1);
assert((to<u32>("file") * 2893426669) >> 29) == 4);
assert((to<u32>("http") * 2893426669) >> 29) == 0);
assert((to<u32>("ws")   * 2893426669) >> 29) == 2);
assert((to<u32>("wss")  * 2893426669) >> 29) == 3);
```
<!-- .element: class="fragment" data-fragment-index="4" -->

----

#### string_to_enum - Minimal perfect hashing

#### lookup table
<!-- .element: class="fragment" style="float:left" data-fragment-index="2" -->
<br />

```cpp
{1, 4, 0, 2, 3}[n]
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
{0b001, 0b100, 0b000, 0b010, 0b011}[n]
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
(0b'001'100'000'010'011 >> 3*n) & 0b111
```
<!-- .element: class="fragment" data-fragment-index="5" -->

---

#### lookup
<!-- .element: class="fragment" style="float:left" data-fragment-index="6" -->
<br />

```cpp
((lut >> (value * magic)) >> shift) & mask

// shift - 29
// mask  - 0b111
// magic - 2893426669 (???)
// lut   - 0b001100000010011 (???)
```
<!-- .element: class="fragment" data-fragment-index="6" -->

----

#### string_to_enum - Minimal perfect hashing

```cpp
template<class E, size_t MaxAttempts = 100'000,
         class T = underlying_type_t<E>> requires is_enum_v<E>
constexpr auto string_to_enum(string_view str) -> E {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  constexpr auto size  = sizeof(T) * CHAR_BIT;
  constexpr auto clz   = countr_zero(max(&enumerators<E>::second));
  constexpr auto nbits = size - clz;
  constexpr auto shift = size - nbits;       // 29
  constexpr auto mask  = (1u << nbits) - 1u; // 0b111
  constexpr auto [magic, lut] = magic_lut(mask, shift, MaxAttempts);
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  auto&& value = to<T>(key);
  return (lut >> ((value * magic) >> shift)) & mask;
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### string_to_enum - Minimal perfect hashing

```cpp
template<class T>
consteval auto magic_lut(auto mask, auto shift, auto max_attempts) {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  while (max_attempts--) {
    magic = random(); // compile-time pseudo random number generation
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
    T lut{};
    for (const auto& [k, v] : enumerators<E>) {
      lut |= (v << (to<T>(k) * magic >> shift));
    }
    for (const auto& [k, v] : enumerators<E>) {
      if ((lut >> (k * magic >> shift) & mask) != v) {
        lut = {}; // not found, keep-going
        break;
      }
    }
    if (magic and lut) return pair{magic, lut}; // found
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  }
  return {};
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### string_to_enum - Minimal perfect hashing - https://godbolt.org/z/3j8qcabsj

```cpp
enum uri { ftp = 0, file = 1, http = 2, ws = 3, wss = 4, };
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
[1]: #uOps    [2]: Latency   [3]: RThroughput
[4]: MayLoad  [5]: MayStore  [6]: HasSideEffects (U)
```
<!-- .element: class="fragment" data-fragment-index="2" -->

<pre><code class="fragment" data-trim data-noescape data-fragment-index="3" data-line-numbers="4,5,6,7,8">
[1] [2] [3]  [4] [5] [6]   Instructions:
 1   1  0.50               shl  edi, 3
 2   5  0.50  *            bzhi eax, dword ptr [rsi], edi
 1   3  1.00               imul eax, eax, 2893426669   /*magic*/
 1   1  0.50               shr  eax, 29                /*shift*/
 1   1  0.50               mov  ecx, 0b001100000010011 /*lut*/
 1   1  0.50               shrx eax, ecx, eax
 1   1  0.25               and  eax, 0b111             /*mask*/
 1   5  0.50          U    ret
</code></pre>

---

```cpp
no lookup table (stored directly in a register)
```
<!-- .element: class="fragment" data-fragment-index="4" -->

----

##### string_to_enum - benchmarks -
##### https://github.com/boost-ext/mph/blob/benchmark/string_to_enum/benchmark.ipynb

<img src="images/benchmark_string_to_enum.png" style="width: 80%; background:none; border:none; box-shadow:none;" />
<!-- .element: class="fragment" data-fragment-index="0" -->

----

##### Perfect hashing - benchmarks - https://boost-ext.github.io/mph/perfect_hashing

<a href="https://boost-ext.github.io/mph/perfect_hashing/"><img src="images/benchmark.png" style="width: 100%; background:none; border:none; box-shadow:none;" /></a>
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### Summary

- ##### Compile-time reflection is a powerful proposal which will impact how C++ is written
<!-- .element: class="fragment" -->

- ##### There is no sliver bullet if it comes to the performance just trade-offs (always measure)
<!-- .element: class="fragment" -->

----

### Let's embrace compile-time reflection!

---

<img src="images/qr.png" style="width: 15%; background:none; border:none; box-shadow:none;" />

---

##### [kris@jusiak.net](mailto:kris@jusiak.net) | [@krisjusiak](https://twitter.com/krisjusiak) | [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)
          </script>
        </section>

      </div>
    </div>

    <script src="reveal.js/lib/js/head.min.js"></script>
    <script src="reveal.js/js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({

        // Display controls in the bottom right corner
        controls: false,

        // Display a presentation progress bar
        progress: false,

        // Display the page number of the current slide
        slideNumber: 'c/t',

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // Hides the address bar on mobile devices
        hideAddressBar: true,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style
        transition: 'none', // none/fade/slide/convex/concave/zoom

        // Transition speed
        transitionSpeed: 'default', // default/fast/slow

        // Transition style for full page slide backgrounds
        backgroundTransition: 'none', // none/fade/slide/convex/concave/zoom

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Parallax background image
        parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // Parallax background size
        parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

        // Number of pixels to move the parallax background per slide
        // - Calculated automatically unless specified
        // - Set to 0 to disable movement along an axis
        parallaxBackgroundHorizontal: null,
        parallaxBackgroundVertical: null,

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true },
          { src: 'extensions/plugin/line-numbers/line-numbers.js' }
        ]
      });

      <!--window.addEventListener("mousedown", handleClick, false);-->
      <!--window.addEventListener("contextmenu", function(e) { e.preventDefault(); }, false);-->

      function handleClick(e) {
        if (1 >= outerHeight - innerHeight) {
          document.querySelector( '.reveal' ).style.cursor = 'none';
        } else {
          document.querySelector( '.reveal' ).style.cursor = '';
        }

        e.preventDefault();
        if(e.button === 0) Reveal.next();
        if(e.button === 2) Reveal.prev();
      }
    </script>

  </body>
</html>
