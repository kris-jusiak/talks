<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Run-time optimizations for compile-time reflection</title>

    <link rel="stylesheet" href="reveal.js/css/reveal.css">
    <link rel="stylesheet" href="reveal.js/css/theme/league.css" id="theme">
    <link rel="stylesheet" href="extensions/plugin/line-numbers/line-numbers.css">
    <link rel="stylesheet" href="extensions/css/highlight-styles/zenburn.css">
    <link rel="stylesheet" href="extensions/css/custom.css">

    <style>
      .reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5 { text-transform: none; }
    </style>

    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );

      function set_address(self, remote, local) {
        if (window.location.search.match("local")) {
          self.href = local;
        } else {
          self.href = remote;
        }
      }
    </script>

    <meta name="description" content="Compile-time reflections">
    <meta name="author" content="Kris Jusiak">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
          <script type="text/template">
          </script>
          </section>

          <section data-markdown=""
                   data-separator="^====+$"
                   data-separator-vertical="^----+$">
          <script type="text/template">
<!-- .element: data-background-image="images/cpponsea.png" -->

<br />&nbsp;
<br />&nbsp;
<br />&nbsp;
<br />&nbsp;
<br />&nbsp;
<br />&nbsp;
<br />&nbsp;
<img src="images/qr.png" style="width: 15%; background:none; border:none; box-shadow:none;" />

---

###### [kris@jusiak.net](mailto:kris@jusiak.net) | [@krisjusiak](https://twitter.com/krisjusiak) | [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)

----

#### Agenda

- #### Reflection
<!-- .element: class="fragment" -->

    - #### Introspection
    <!-- .element: class="fragment" -->

    - #### Meta-Programming
    <!-- .element: class="fragment" -->

- #### [Performance] Case study
<!-- .element: class="fragment" -->

    - ##### enum_to_string
    <!-- .element: class="fragment" -->

    - ##### string_to_enum
    <!-- .element: class="fragment" -->

- #### Examples
<!-- .element: class="fragment" -->

- #### Summary
<!-- .element: class="fragment" -->

----

#### Disclaimer

- ##### Proposal based ([P1306](https://wg21.link/P1306), [P1858](https://wg21.link/P1858), [P1928](https://wg21.link/P1928), [P2996](https://wg21.link/P2996), [P3294](https://wg21.link/P3294))
<!-- .element: class="fragment" -->

- ##### x86-64 focused
<!-- .element: class="fragment" -->

    - ##### https://github.com/bloomberg/clang-p2996
    <!-- .element: class="fragment" -->

- ##### C++20
<!-- .element: class="fragment" -->

  - ##### https://github.com/boost-ext
  <!-- .element: class="fragment" -->

----

#### Reflection for C++26 - https://wg21.link/P2996

- ##### Static (compile-time)
<!-- .element: class="fragment" data-fragment-index="0" -->

- ##### Value/consteval based
<!-- .element: class="fragment" data-fragment-index="1" -->

- ##### Supports introspection/meta-programming
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### P2996 - introspection

```cpp
namespace std::meta {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  // #member-queries
  consteval auto enumerators_of(info) -> vector<info>;
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  // #name and location
  consteval auto name_of(info) -> string_view;
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  // more...
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
using info = decltype(^::); // type-erased AST info
```
<!-- .element: class="fragment" data-fragment-index="4" -->

----

#### P2996 - meta-programming

```cpp
[: // splicer (reify)
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
  ^T // lift (reflexpr)
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
:]
```
<!-- .element: class="fragment" data-fragment-index="3" -->

---

```cpp
static_assert(
  typeid(^T) == typeid(meta::info)
);
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
static_assert(
  typeid(typename[:^int:]) == typeid(int)
);
```
<!-- .element: class="fragment" data-fragment-index="5" -->


----

##### P2996 / meta-programming (https://godbolt.org/z/43Yf8G8xz)

```cpp
template<size_t N, class... Ts>
using at =
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  typename [: // splicer (reify)
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
    array{^Ts...}[N] // lift into array{meta::info}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  :];
```
<!-- .element: class="fragment" data-fragment-index="2" -->

---

```cpp
static_assert(typeid(int)   == typeid(at<0, int, float, short>));
static_assert(typeid(float) == typeid(at<1, int, float, short>));
static_assert(typeid(short) == typeid(at<2, int, float, short>));
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

##### C++26 - Generalized pack declaration and usage (https://wg21.link/P1858)
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
template<size_t N, class... Ts>
using at = Ts...[N];
```
<!-- .element: class="fragment" data-fragment-index="4" -->


----

##### P2996 + ranges / meta-programming (https://godbolt.org/z/Y7edbe63c)

```cpp
template<class... Ts>
using reverse_drop_t = typename [:
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
    meta::substitute(^type_list,
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
        array{^Ts...} // array{meta::info}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
      | views::reverse
      | views::drop(1)
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
    )
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
:];
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
static_assert(typeid(reverse_drop_t<int, float, short>) ==
              typeid(type_list<float, int>));
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

##### P2996 - meta-programming / compilation times - https://github.com/boost-ext/mp/tree/benchmark

<a href="https://boost-ext.github.io/mp"><img src="images/bench.png" style="width: 100%; background:none; border:none; box-shadow:none;" /></a>

##### Meta-Programming model possible since C++17 (msvc, gcc, clang) - https://github.com/boost-ext/mp
<!-- .element: class="fragment" data-fragment-index="0" -->

----

### [Performance] Case study

----

#### Latency Numbers Every Programmer Should Know

<img src="images/latency.png" style="width: 50%; background:white; border:none; box-shadow:none;" />
<!-- .element: class="fragment" data-fragment-index="0" -->

---

- #### LLVM Machine Code Analyzer - https://llvm.org/docs/CommandGuide/llvm-mca.html
<!-- .element: class="fragment" data-fragment-index="1" -->

- #### Instruction Tables - https://www.agner.org/optimize/instruction_tables.pdf
<!-- .element: class="fragment" data-fragment-index="2" -->

----

### enum_to_string

----

#### Enum - https://eel.is/c++draft/dcl.enum

#### Unscoped Enum (C-style Enum)
<!-- .element: class="fragment" style="float:left" -->
<br />

```cpp
enum color { red, green, blue, };
```
<!-- .element: class="fragment" -->

---

#### Scoped Enum (C++11)
<!-- .element: class="fragment" style="float:left" -->
<br />

```cpp
enum class http_status_code : uint32_t {
  ok = 200, not_found = 404, bad_gateway = 502,
};
```
<!-- .element: class="fragment" -->

---

#### 'Flag' Enum (not a standard term)
<!-- .element: class="fragment" style="float:left" -->
<br />

```cpp
enum class permissions : uint8_t {
  read     = (1 << 0), // 0b00000001
  write    = (1 << 1), // 0b00000010
  execute  = (1 << 2), // 0b00000100
};
```
<!-- .element: class="fragment" -->

----

#### enum_to_string - how hard it can be?

```cpp
enum { A = 1, B = 1, };
```
<!-- .element: class="fragment" -->

```cpp
enum_to_string(A); // ?
enum_to_string(B); // ?
```
<!-- .element: class="fragment" -->

---

```cpp
enum flag_enum { A = 0b01, B = 0b10, };
```
<!-- .element: class="fragment" -->

```cpp
enum_to_string(A | B); // ?
```
<!-- .element: class="fragment" -->

---

```cpp
enum E { A };
```
<!-- .element: class="fragment" -->

```cpp
enum_to_string(static_cast<E>(42)); // ?
```
<!-- .element: class="fragment" -->

----

#### enum_to_string - P2996

```
template <class E> requires is_enum_v<E>
constexpr auto enum_to_string(E value) -> string_view {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  template for (constexpr auto e : meta::enumerators_of(^E)) {
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
    if (value == [:e:]) {
      return meta::name_of(e);
    }
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
  }
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  return {};
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

##### Expansion statements* (https://wg21.link/P1306)
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### enum_to_string - P2996

```cpp
enum color { red, green, blue, };
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
template <class E> requires is_enum_v<E>
constexpr auto enum_to_string(E value) -> string_view {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  if (value == color::red)   { return "red";   }
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  if (value == color::green) { return "green"; }
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
  if (value == color::blue)  { return "blue";  }
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
  return {};
```
<!-- .element: class="fragment" data-fragment-index="5" -->

```
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### enum_to_string - P2996

```cpp
[1]: #uOps    [2]: Latency   [3]: RThroughput
[4]: MayLoad  [5]: MayStore  [6]: HasSideEffects (U)
```
<!-- .element: class="fragment" data-fragment-index="2" -->

---

```cpp
[1]    [2]    [3]    [4] [5] [6]  Instructions:
 1      1     0.25                test  edi, edi
 1      1     0.50                je    .LBB0_1
 1      1     0.25                cmp   edi, 1
 1      1     0.50                jne   .LBB0_4
 1      1     0.50                mov   eax, 5
 1      1     0.33                lea   rdx, [rip + .L.str.1]
 1      5     0.50            U   ret
 1      1     0.50                mov   eax, 3
 1      1     0.33                lea   rdx, [rip + .L.str]
 1      5     0.50            U   ret
 1      1     0.50                mov   eax, 4
 1      1     0.33                lea   rdx, [rip + .L.str.2]
 1      5     0.50            U   ret
```
<!-- .element: class="fragment" data-fragment-index="3" -->

----

#### Performance is a shape not a number!

```cpp
enum_to_string("red");
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
enum_to_string("green");
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
enum_to_string("blue");
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

### switch-case

----

##### switch-case - lowering strategies - https://github.com/gcc-mirror/gcc/blob/master/gcc/tree-switch-conversion.cc

##### bitset (gcc)
<!-- .element: class="fragment" style="float:left" -->
```cpp
auto bit_test_cluster::is_beneficial(auto count, auto uniq) {
  // count: number of cases, uniq: number of distinct values
  return (uniq==1 && count>=3) || (uniq==2 && count>=5) ||
         (uniq==3 && count>=6);
}
```
<!-- .element: class="fragment" -->

##### jump-table<br />(gcc/clang)
<!-- .element: class="fragment" style="float:left" -->

```cpp
auto jump_table_cluster::can_be_handled(auto cmp_count) {
  return get_range(get_low(), get_high()) <=
    (optimize_for_size() ? 2 : 8) * cmp_count;
}

auto jump_table_cluster::is_beneficial(auto start, auto end) {
  return end - start + 1 >= 5;
}
```
<!-- .element: class="fragment" -->

##### else &nbsp;
<!-- .element: class="fragment" style="float:left" -->

##### decision tree comparisons (gcc/clang)
<!-- .element: class="fragment" style="float:left" -->

----

#### Let's make some helper utilities with P2996

```cpp
template<class E> requires is_enum_v<E>
inline constexpr auto enumerators =
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  []<size_t... Ns>(index_sequence<Ns...>) {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
    return array{
      pair{
        [: meta::enumerators_of(^E)[Ns] :],
        meta::name_of(meta::enumerators_of(^E)[Ns])
      }...
    };
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```
}(make_index_sequence<meta::enumerators_of(^E).size()>{});
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### Let's make some helper utilities with P2996

```cpp
enum color { red, green, blue, };
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
static_assert(
  enumerators<color>
  ==
  array{
    pair{color::red,   "red"},
    pair{color::green, "green"},
    pair{color::blue,  "blue"},
  }
);
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### switch-case - https://godbolt.org/z/Mc5Yvsrxc

```cpp
template <class E> requires is_enum_v<E>
constexpr auto enum_to_string(E value) {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  return [value]<size_t I = {}>(this auto&& self) -> string_view {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
    switch (value) {
      default:
        if constexpr (I < enumerators<E>.size() - 1u)
          return self.template operator()<I + 1u>();
        else
          return {};

      case enumerators<E>[I].first:
          return enumerators<E>[I].second;
    }
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  }();
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### switch-case - https://godbolt.org/z/E5en4K8qn

```cpp
enum class http_status_code : uint32_t {
  ok         = 200,  // first cluster
  created    = 201,
  accepted   = 202,
  no_content = 204,
  im_used    = 226,  // odd value
  forbidden  = 403,  // second cluster
  not_found  = 404,
};
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### switch-case - https://godbolt.org/z/E5en4K8qn

```cpp
[1]: #uOps    [2]: Latency   [3]: RThroughput
[4]: MayLoad  [5]: MayStore  [6]: HasSideEffects (U)
```
<!-- .element: class="fragment" data-fragment-index="0" -->

<pre><code class="fragment" data-trim data-noescape data-fragment-index="1" data-line-numbers="1,6,9,14">
[1] [2] [3]  [4] [5] [6]  Instructions:
 1   1  0.33              lea eax, [rdi - 200]
 1   1  0.25              cmp eax, 5
 1   1  0.50              jae .LBB0_1
 1   1  0.50              mov ecx, 23
 1   1  0.50              bt ecx, eax  /*bitset*/
 1   1  0.50              jae .LBB0_1
 1   0  0.17              mov eax, eax /*jump-table*/
 1   1  0.33              lea rcx, [rip + .Lswitch.table]
 1   5  0.33  *           movsxd rax, dword ptr [rcx + 4*rax]
 1   1  0.25              add rax, rcx
 1   5  0.50          U   ret
 1   0  0.17              xor eax, eax
 1   1  0.25              cmp edi, 226 /*decision tree*/
 1   1  0.33              lea rax, [rip + .L.str.4]
 1   1  0.50              cmovne rax, rcx
 1   5  0.50          U   ret
</code></pre>

----

#### Code Injection with Token Sequences - https://wg21.link/P3294

example

----

#### Want performance? Know your hardware!

----

#### Single Instruction, Multiple Data - SIMD

<img src="images/simd.png" style="width: 80%; background:white; border:none; box-shadow:none;" />
<!-- .element: class="fragment" data-fragment-index="0" -->

#### std::simd - https://wg21.link/P1928
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### std::simd - https://godbolt.org/z/9c44jGnW6

```cpp
static_assert(4u  == simd_size_v<uint32_t>); // x86.sse     (128 bits)
static_assert(8u  == simd_size_v<uint32_t>); // x86.avx     (256 bits)
static_assert(16u == simd_size_v<uint32_t>); // x86.avx512f (512 bits)
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
template <class E> requires is_enum_v<E> and
  (enumerators<E>.size() <= simd_size_v<underlying_type_t<E>>)
constexpr auto enum_to_string(E value) -> string_view {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  simd<underlying_type_t<E>> lhs{value};
  simd<underlying_type_t<E>> rhs{[&](auto i) {
    return (i < enumerators<E>.size()) ? enumerators<E>[i].first : 0; }
  };
  const auto match = lhs == rhs; // compare N elements at once
  return any_of(match)
    ? enumerators<E>[find_first_set(match)].second
    : {};
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### std::simd - https://godbolt.org/z/9c44jGnW6

```cpp
[1]: #uOps    [2]: Latency   [3]: RThroughput
[4]: MayLoad  [5]: MayStore  [6]: HasSideEffects (U)
```
<!-- .element: class="fragment" data-fragment-index="0" -->

<pre><code class="fragment" data-trim data-noescape data-fragment-index="1" data-line-numbers="4,5,6,8">
[1] [2] [3]  [4] [5] [6]  Instructions:
 1   1  1.00              vmovd xmm1, edi
 1   0  0.17              xor edx, edx
 1   1  0.50              vpbroadcastd  xmm0, xmm1
 1   8  0.50  *           vpcmpeqd xmm0, xmm0, xmmword ptr[rip+.keys]
 1   1  1.00              vmovmskps eax, xmm0
 1   1  0.25              movzx eax, al
 6   3  3.00              rep bsf eax, eax
 1   1  0.50              shl rax, 4
 1   5  0.33  *           mov rdx, qword ptr [rax + enumerators+8]
 1   5  0.50          U   ret
</code></pre>

```cpp
keys:                enumerators:
  .long   0            .quad   "red"
  .long   1            .quad   "green"
  .long   2            .quad   "blue"
  .long   0            .quad   ""
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### Want performance? Know your data!

----

##### Perfect hashing - https://en.wikipedia.org/wiki/Perfect_hash_function

<img src="images/hashing.png" style="width: 75%; background:white; border:none; box-shadow:none;" />
<!-- .element: class="fragment" data-fragment-index="0" -->

-----

#### Perfect hashing - approaches

<table><tr><td>
<a href="https://link.springer.com/chapter/10.1007/978-3-642-04128-0_61"><img src="images/hdc.png" style="width: 92%; background:none; border:none; box-shadow:none;" /></a>
</td>
<td>
<a href="https://arxiv.org/pdf/2104.10402"><img src="images/pthash.png" style="width: 90%; background:none; border:none; box-shadow:none;" /></a>
</td></tr></table>

-----

#### Hardware accelerated perfect hashing

<img src="images/idea.png" style="width: 50%; background:none; border:none; box-shadow:none;" />
<!-- .element: class="fragment" data-fragment-index="0" -->

##### [Using std::cpp: Joaquín M. López Muñoz - Perfect Hashing in an Imperfect World](https://www.youtube.com/watch?v=yOo6GnbKzp8)
<!-- .element: class="fragment" data-fragment-index="1" -->

-----

#### Hardware accelerated perfect hashing

<img src="images/pext.png" style="width: 100%; background:none; border:none; box-shadow:none;" />
<!-- .element: class="fragment" data-fragment-index="0" -->

###### https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=pext
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### Hardware accelerated perfect hashing

```cpp
template <class E> requires is_enum_v<E>
constexpr auto enum_to_string(E value) const -> string_view {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  static constexpr auto lookup = [] {
    array<pair<E, string_view>, (1u << std::popcount(mask))> lookup{};
    for (const auto& [k, v] : enumerators<E>) {
      lookup[pext(k, mask<E>)] = {k, v};
    }
    return lookup;
  }();
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  auto&& lhs = value;
  auto&& [rhs, result] = lookup[pext(lhs, mask<E>)];
  return lhs == rhs ? result : {};
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### Hardware accelerated perfect hashing - mask

```cpp
template<class E, class T = underlying_type_t<E>> requires is_enum_v<E>
consteval auto mask() {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  bitset<sizeof(T)*CHAR_BIT> mask(numeric_limits<T>::max()); // 0b111...
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  // #pragma omp parallel for
  for (auto i = 0u; i < mask.size(); ++i) {
    mask.flip(i);
    if (not unique(enumerators<E>, mask)) {
      mask.flip(i);
    }
  }
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  assert(is_unique(mask));
  return mask.to_ullong();
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
time $CXX -std=c++20 -O3 64_keys.cpp -c -DNTEST  # 0.043s
time $CXX -std=c++20 -O3 64_keys.cpp -c          # 0.090s
```
<!-- .element: class="fragment" data-fragment-index="4" -->

-----

#### Hardware accelerated perfect hashing - https://godbolt.org/z/j4E5Pcjx1

```cpp
[1]: #uOps    [2]: Latency   [3]: RThroughput
[4]: MayLoad  [5]: MayStore  [6]: HasSideEffects (U)
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
[1]    [2]    [3]    [4] [5] [6]  Instructions:
 1      0     0.17                mov ecx, edi
 1      1     0.25                and ecx, 3
 1      1     0.50                shl ecx, 4
 1      1     0.33                lea rdx, [rip + lookup]
 1      0     0.17                xor eax, eax
 1      5     0.33    *           cmp dword ptr [rcx + rdx], edi
 1      5     0.50    *           cmove rax, qword ptr [rcx + rdx + 8]
 1      5     0.50            U   ret
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
lookup:
 .long   0 .quad   "red"
 .long   1 .quad   "green"
 .long   2 .quad   "blue"
 .zero   16
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### [Improvement] If the input can be guaranteed to be valid

```cpp
          assert(contains(enumerators, value)); // valid input
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### Hardware accelerated perfect hashing - unsafe - https://godbolt.org/z/3hMxEoG5h

```cpp
template <class E> requires is_enum_v<E>
constexpr auto unsafe$enum_to_string(E value) -> string_view {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  [[assume(contains(enumerators, value)]];
  return lookup[pext(value, mask<E>)];
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### Hardware accelerated perfect hashing - unsafe - https://godbolt.org/z/3hMxEoG5h

```cpp
[1]: #uOps    [2]: Latency   [3]: RThroughput
[4]: MayLoad  [5]: MayStore  [6]: HasSideEffects (U)
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
[1]    [2]    [3]    [4] [5] [6]  Instructions:
 1      1     0.25                and edi, 3
 1      1     0.25                shl edi, 4
 1      1     0.25                lea rax, [rip + lookup]
 1      4     0.50    *           mov rax, qword ptr [rdi + rax + 8]
 2      1     0.50            U   ret
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
lookup:
  .quad   "red"
  .quad   "green"
  .quad   "blue"
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### What about 'Flag' enum?

```cpp
enum class permissions : uint8_t {
  read     = (1 << 0), // 0b001
  write    = (1 << 1), // 0b010
  execute  = (1 << 2), // 0b100
  // ----------------------------//
  // mask  :              0b111  // size: 2^(popcount(mask))
  // ----------------------------//
};
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### Flag enum - https://godbolt.org/z/aM7E1bTPz

```cpp
template<class E>
concept flag_enum = is_enum_v<E> and [] {
  for (const auto& enumeration : meta::enumerators_of(^E)) {
    if (not has_single_bit(to_underlying(enumeration))) {
      return false;
    }
  }
  return true;
}();
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
enum class f1 { a = 0, b = 1, c = 2, };
enum class f2 { a = 1, b = 2, c = 16, };
enum class f3 { a = 1, b = 2, c = 7, };

static_assert(flag_enum<f1>);
static_assert(flag_enum<f2>);
static_assert(not flag_enum<f3>);
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### Flag enum - https://godbolt.org/z/aM7E1bTPz

```cpp
constexpr auto unsafe$enum_to_string(flag_enum value) {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  static constexpr auto lookup = [] {
    array<string_view, enumerators<E>.size()> lookup{};
    for (auto i = 0u; const auto& [_, name] : enumerators<E>) {
      lookup[i++] = name;
    }
    return lookup;
  }();
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  [[assume(has_single_bit(to_underlying(value))]];
  return lookup[popcount(to_underlying(value) - 1)];
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
4         = 0b100
4 - 1 = 3 = 0b011 = popcount(0b011) = 2 // or countr_zero
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### Flag enum - https://godbolt.org/z/4cc8MabjG

```cpp
[1]: #uOps    [2]: Latency   [3]: RThroughput
[4]: MayLoad  [5]: MayStore  [6]: HasSideEffects (U)
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
[1]    [2]    [3]    [4] [5] [6]  Instructions:
 1      1     0.25                dec edi
 1      1     0.25                popcnt eax, edi
 1      1     0.33                lea rcx, [rip + lookup]
 1      5     0.33    *           mov rax, qword ptr [rcx + 8*rax]
 1      5     0.50            U   ret
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
lookup:
  .quad   "red"
  .quad   "green"
  .quad   "blue"
```
<!-- .element: class="fragment" data-fragment-index="2" -->

-----

#### No BMI2? Zen2? ARM?

```cpp
// bmi2
mov     ecx, 789
pext    ecx, eax, ecx
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
// no bmi2
mov     ecx, eax
and     ecx, 789
imul    ecx, ecx, 57
shr     ecx, 2
and     ecx, 248
```
<!-- .element: class="fragment" data-fragment-index="2" -->

#### <a href="https://schedule.cppnow.org/session/2024/a-case-study-in-zero-cost-abstractions-high-performance-message-dispatch/">C++Now 2024 - Luke Valenty: A case study in zero-cost abstractions: High performance message dispatch</a>
<!-- .element: class="fragment" data-fragment-index="3" -->

----

#### There is no sliver bullet!

```cpp
template <class E> requires is_enum_v<E> and
  (enumerators<E>.size() <= simd_size_v<underlying_type_t<E>>)
[[gnu::target("sse, sse2, sse4.1, avx, avx2, avx512f")]]
constexpr auto enum_to_string(E value) -> string_view;
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
template<class E> requires is_enum_v<E>
[[gnu::target("default")]]
constexpr auto enum_to_string(E value) -> string_view;
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
[[gnu::target("default")]]
constexpr auto enum_to_string(flag_enum value) -> string_view;
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
...
```
<!-- .element: class="fragment" data-fragment-index="4" -->

----

#### Benchmarks - https://github.com/boost-ext/mph/tree/benchmark

----

### string_to_enum

----

#### string_to_enum - if/else - https://godbolt.org/z/Yha87c9f3

```cpp
template<class E> requires is_enum_v<E>
constexpr auto string_to_enum(string_view str) -> optional<E> {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  if (str == "red")   { return color::red;   }
  if (str == "green") { return color::green; }
  if (str == "blue")  { return color::blue;  }

  return nullopt;
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### string_to_enum - switch-case - https://godbolt.org/z/Yha87c9f3

```cpp
template<class E> requires is_enum_v<E>
constexpr auto string_to_enum(string_view str) -> optional<E> {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  switch (hash(str)) {
    case hash("red"):   return color::red;
    case hash("green"): return color::green;
    case hash("blue"):  return color::blue;
  }
  return nullopt;
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### string_to_enum - trie - https://godbolt.org/z/Yha87c9f3

```cpp
enum color { red, green, blue, black };
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
template<class E> requires is_enum_v<E>
constexpr auto string_to_enum(string_view str) -> optional<E> {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  switch (str[0]) {
    case 'r': return color::red;
    case 'g': return color::green;
    case 'b': {
      switch (str[2]) { // or size
        case 'u': return color::blue;
        case 'a': return color::black;
      }
    }
  }
  return nullopt;
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### string_to_enum - map - https://godbolt.org/z/Yha87c9f3

```cpp
template<class E> requires is_enum_v<E>
constexpr auto string_to_enum(string_view str) {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  static const unordered_map<string_view, E> map{
    {"red",   color::red},
    {"green", color::green},
    {"blue",  color::blue},
  };
  return map.at(str);
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

##### https://github.com/serge-sans-paille/frozen
<!-- .element: class="fragment" data-fragment-index="2" -->

----

##### string_to_enum - [gperf](https://www.gnu.org/software/gperf)

<a href="https://www.gnu.org/software/gperf/"><img src="images/gperf.png" style="width: 45%; background:none; border:none; box-shadow:none;" /></a>

----

### string_to_enum

#### Back to the basics!
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### string to int - https://godbolt.org/z/GnKoK9vrj

```cpp
static_assert(3 + 1 == sizeof("cpp"));
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```
int32_t        :  4 bytes
int64_t        :  8 bytes
simd<char, 16> : 16 bytes // x86.sse
simd<char, 32> : 32 bytes // x86.avx
simd<char, 64> : 64 bytes // x86.avx512
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

##### simd<char, N> can be used to implement optimized string
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### string to int - https://godbolt.org/z/GnKoK9vrj

```cpp
template<class T, size_t Size> requires (Size <= sizeof(T))
constexpr auto to(const char (&str)[Size]) -> T {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  T t{};
  memcpy(&t, str, Size); // optimized
  return t;
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
template<class T>
constexpr auto to(string_view str) -> T {
  T t{};
  assert(str.size() <= sizeof(T));
  memcpy(&t, str.data(), str.size()); // slow
  return t;
}
```
<!-- .element: class="fragment" data-fragment-index="3" -->

----

#### string to int - https://godbolt.org/z/GnKoK9vrj

```cpp
template<class T>
constexpr auto to(string_view str) -> T {
  T t;
  memcpy(&t, str.data(), sizeof(t)); // potentially unsafe
  return bzhi(t, str.size() * CHAR_BIT);
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

<a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=bzhi"><img src="images/bzhi.png" style="width: 52%; background:none; border:none; box-shadow:none;" /></a>
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### string to int - https://godbolt.org/z/GnKoK9vrj

```cpp
[[gnu::target("default")]] auto bzhi(auto value, auto index) {
  return value & ((1u << index) - 1u);
}
[[gnu::target("bmi2")]] auto bzhi(uint32_t value, uint32_t index) {
  return _bzhi_u32(value, index);
}
[[gnu::target("bmi2")]] auto bzhi(uint64_t value, uint64_t index) {
  return _bzhi_u64(value, index);
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
template auto to<uint32_t>(string_view) -> uint32_t;
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
// $CXX -Ofast -DNDEBUG -mbmi2
sal  rdi, 3
bzhi eax, DWORD PTR [rsi], edi
ret
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### string to int - https://godbolt.org/z/GnKoK9vrj

```cpp
template<class T, size_t PageSize = 4096u>
constexpr auto to(string_view str) {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  // https://github.com/glibc/blob/master/sysdeps/generic/memcopy.h
  if ((uint64_t(str.data()) & (PageSize - 1ul)) >
      (PageSize - sizeof(T))) [[unlikely]] { // page boundary
    return [&str] [[gnu::cold]] {
      T t;
      memcpy(&t, str.data(), str.size()); // slow path
      return t;
    }();
  }
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  T t{};
  memcpy(&t, str.data(), sizeof(t)); // fast path
  return bzhi(t, str.size() * CHAR_BIT);
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

### string_to_enum

----

#### std::simd

----

#### Hardware accelerated perfect hashing

```cpp
template <class E> requires is_enum_v<E>
constexpr auto string_to_enum(std::string_view str) -> E {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  static constexpr auto lookup = /* same as in enum_to_string */;
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  auto&& lhs = to<T>(str); // T - uint32_t/uint64_t/...
  auto&& [rhs, result] = lookup[pext(lhs, mask<E>)];
  return (lhs == rhs) * result;
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

assembly

----

#### Minimal perfect hashing

<img src="images/hashing.png" style="width: 75%; background:white; border:none; box-shadow:none;" />
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### Minimal perfect hashing

#### bit mixer
<!-- .element: class="fragment" style="float:left" data-fragment-index="0" -->
<br />

```cpp
(value * magic) >> shift
```
<!-- .element: class="fragment" data-fragment-index="1" -->

#### lookup table
<!-- .element: class="fragment" style="float:left" data-fragment-index="2" -->
<br />

```cpp
{7, 42, 1, 10}[n]
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
{0b000111, 0b101010, 0b000001, 0b001010}[n]
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
(0b'000111'101010'000001'001010 >> 6*n) & 0b111111
```
<!-- .element: class="fragment" data-fragment-index="5" -->

#### magic
<!-- .element: class="fragment" style="float:left" data-fragment-index="6" -->
<br />

```cpp
// value: input
// shift: known
// mask:  known
// magic: ???
// lut:   ???
((lut >> (value * magic)) >> shift) & mask
```
<!-- .element: class="fragment" data-fragment-index="6" -->

----

#### Minimal perfect hashing

```cpp
template<class E, size_t MaxAttempts = 100'000> requires is_enum_v<E>
constexpr auto string_to_enum(string_view str) -> E {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  constexpr auto size  = sizeof(T) * CHAR_BIT; // T = uint32_t/...
  constexpr auto nbits = size - countr_zero(max(enumerators<E>));
  constexpr auto mask  = (1u << nbits) - 1u; // 0b111111...
  constexpr auto shift = size - nbits;
  constexpr auto [magic, lut] = magic_lut(mask, shift, MaxAttempts);
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  auto&& value = to<T>(key);
  return (lut >> ((value * magic) >> shift)) & mask;
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### Minimal perfect hashing

```cpp
template<class T>
consteval auto magic_lut(auto mask, auto shift, auto max_attempts) {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  while (max_attempts--) {
    magic = random(); // compile-time random number generation
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
    T lut{};
    for (const auto& [k, v] : enumerators<E>) {
      lut |= (v << (to<T>(k) * magic >> shift));
    }
    for (const auto& [k, v] : enumerators<E>) {
      if ((lut >> (k * magic >> shift) & mask) != v) {
        lut = {}; // not found, keep-going
        break;
      }
    }
    if (magic and lut) return pair{magic, lut}; // found
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  }
  return {};
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### Minimal perfect hashing - https://godbolt.org/z/3j8qcabsj

```cpp
enum uri { ftp = 1, file = 2, http = 3, ws = 4, wss = 5, };
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
[1]: #uOps    [2]: Latency   [3]: RThroughput
[4]: MayLoad  [5]: MayStore  [6]: HasSideEffects (U)
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
[1]    [2]    [3]    [4] [5] [6]    Instructions:
 1      1     0.50                  shl edi, 3
 2      5     0.50    *             bzhi eax, dword ptr [rsi], edi
 1      3     1.00                  imul eax, eax, 385596323 // magic
 1      1     0.50                  shr eax, 29              // shift
 1      1     0.50                  mov ecx, 358             // lut
 1      1     0.50                  shrx eax, ecx, eax
 1      1     0.25                  and eax, 7               // mask
 1      5     0.50            U     ret
```
<!-- .element: class="fragment" data-fragment-index="3" -->

---

```cpp
no lookup table (stored directly in a register)
```
<!-- .element: class="fragment" data-fragment-index="4" -->

----

#### Benchmarks - https://github.com/boost-ext/mph/tree/benchmark

---

##### Enum with 100 elements, successful lookup (Just a hook)
<!-- .element: class="fragment" -->

```cpp
| 0.36ms | std::map
```
<!-- .element: class="fragment" -->

```cpp
| 0.18ms | std::unordered_map
```
<!-- .element: class="fragment" -->

```cpp
| 0.09ms | gperf
```
<!-- .element: class="fragment" -->

```cpp
| 0.02ms | Hardware accelerated perfect hashing
```
<!-- .element: class="fragment" -->

----

### Examples

----

#### Nasdaq TotalView-ITCH 5.0 - https://www.nasdaqtrader.com

<img src="images/nasdaq.png" style="width: 80%; background:none; border:none; box-shadow:none;" />

-----

#### Nasdaq TotalView-ITCH 5.0 - https://godbolt.org/z/n8Ex73e6P

```cpp
constexpr auto symbols = array{
  pair{"    AMZN"sv, 1},
  pair{"    AAPL"sv, 2},
  pair{"   GOOGL"sv, 3},
  pair{"    META"sv, 4},
  pair{"    MSFT"sv, 5},
  pair{"    NVDA"sv, 6},
  pair{"    TSLA"sv, 7},
};
```
<!-- .element: class="fragment" -->

```cpp
array<uint32_t, order_book> order_books{}; // 0 is special
```
<!-- .element: class="fragment" -->

```cpp
constexpr auto on(const add_order& msg) {
  order_book[*find<symbols>(msg.stock)].on(msg);
}
```
<!-- .element: class="fragment" -->

----

#### Nasdaq TotalView-ITCH 5.0 - https://godbolt.org/z/n8Ex73e6P

```cpp
[1]: #uOps    [2]: Latency   [3]: RThroughput
[4]: MayLoad  [5]: MayStore  [6]: HasSideEffects (U)
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
[1]    [2]    [3]    [4] [5] [6]  Instructions:
 1      5     0.33    *           mov rax, qword ptr [rsi + 8]
 1      5     0.33    *           mov rcx, qword ptr [rax]
 1      1     1.00                movabs rax, 4419538124800 // mask
 1      3     1.00                pext rdx, rcx, rax
 1      1     0.50                shl edx, 4
 1      1     0.33                lea rsi, [rip + find<symbols>]
 1      0     0.17                xor eax, eax
 1      5     0.33    *           cmp qword ptr [rdx + rsi], rcx
 1      5     0.50    *           cmove eax, dword ptr [rdx + rsi + 8]
 1      5     0.50            U   ret
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
find<symbols>:
  .quad 5498966892987031584 /* AAPL */ .long 2
  .quad 4705227331476660256 /* TSLA */ .long 7
  ...
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

### Summary

- ##### Compile-time reflection opens new possibilities
<!-- .element: class="fragment" -->

- ##### There is no sliver bullet if it comes to the performance just trade-offs
<!-- .element: class="fragment" -->

- ##### Performance is a shape not a number (always measure)
<!-- .element: class="fragment" -->

----

### Let's embrace compile-time reflection!

---

#### Reflection for C++ - https://wg21.link/P2996
<!-- .element: class="fragment" -->

#### C++20 - https://github.com/boost-ext
<!-- .element: class="fragment" -->

---

###### [kris@jusiak.net](mailto:kris@jusiak.net) | [@krisjusiak](https://twitter.com/krisjusiak) | [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)
          </script>
        </section>

      </div>
    </div>

    <script src="reveal.js/lib/js/head.min.js"></script>
    <script src="reveal.js/js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({

        // Display controls in the bottom right corner
        controls: false,

        // Display a presentation progress bar
        progress: false,

        // Display the page number of the current slide
        slideNumber: 'c/t',

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // Hides the address bar on mobile devices
        hideAddressBar: true,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style
        transition: 'none', // none/fade/slide/convex/concave/zoom

        // Transition speed
        transitionSpeed: 'default', // default/fast/slow

        // Transition style for full page slide backgrounds
        backgroundTransition: 'none', // none/fade/slide/convex/concave/zoom

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Parallax background image
        parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // Parallax background size
        parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

        // Number of pixels to move the parallax background per slide
        // - Calculated automatically unless specified
        // - Set to 0 to disable movement along an axis
        parallaxBackgroundHorizontal: null,
        parallaxBackgroundVertical: null,

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true },
          { src: 'extensions/plugin/line-numbers/line-numbers.js' }
        ]
      });

      <!--window.addEventListener("mousedown", handleClick, false);-->
      <!--window.addEventListener("contextmenu", function(e) { e.preventDefault(); }, false);-->

      function handleClick(e) {
        if (1 >= outerHeight - innerHeight) {
          document.querySelector( '.reveal' ).style.cursor = 'none';
        } else {
          document.querySelector( '.reveal' ).style.cursor = '';
        }

        e.preventDefault();
        if(e.button === 0) Reveal.next();
        if(e.button === 2) Reveal.prev();
      }
    </script>

  </body>
</html>
