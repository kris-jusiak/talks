<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Template-less Metaprogramming</title>

    <link rel="stylesheet" href="reveal.js/css/reveal.css">
    <link rel="stylesheet" href="reveal.js/css/theme/league.css" id="theme">
    <link rel="stylesheet" href="extensions/plugin/line-numbers/line-numbers.css">
    <link rel="stylesheet" href="extensions/css/highlight-styles/zenburn.css">
    <link rel="stylesheet" href="extensions/css/custom.css">

    <style>
      .reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5 { text-transform: none; }
    </style>

    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );

      function set_address(self, remote, local) {
        if (window.location.search.match("local")) {
          self.href = local;
        } else {
          self.href = remote;
        }
      }
    </script>

    <meta name="description" content="Compile-time reflections">
    <meta name="author" content="Kris Jusiak">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
          <script type="text/template">
          </script>
          </section>

          <section data-markdown=""
                   data-separator="^====+$"
                   data-separator-vertical="^----+$">
          <script type="text/template">
<a href="https://cppcon.org/"><img src="images/logo.png" style="width: 35%; background:none; border:none; box-shadow:none;" /></a>

---

## Template-less Metaprogramming

<img src="images/qr.png" style="width: 15%; background:none; border:none; box-shadow:none;" />

---

##### [kris@jusiak.net](mailto:kris@jusiak.net) | [@krisjusiak](https://twitter.com/krisjusiak) | [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)

----

#### Agenda

- #### Motivation
<!-- .element: class="fragment" -->
  - #### Examples
<!-- .element: class="fragment" -->

- #### Template Metaprogramming (TMP)
<!-- .element: class="fragment" -->

  - #### Approches / Implementation
  <!-- .element: class="fragment" -->

  - #### Benchmarks
  <!-- .element: class="fragment" -->

- #### Summary
<!-- .element: class="fragment" -->

---

###### Powered by [Compiler Explorer](https://godbolt.org)
<!-- .element: class="fragment" -->

----

#### Template Metaprogramming

> ###### `is a technique to generate code at compile-time` <hr />
```cpp
std::vector<T>
std::variant<Ts...>
template<class InputIt, class T>
T accumulate(InputIt first, InputIt last, T init);
...
```
<!-- .element: class="fragment" -->

##### <C++ superpower>
<!-- .element: class="fragment" -->

----

### Motivation / Examples

----

#### Standard Template Library (STL) - https://godbolt.org/z/TKPdYPv3P

```cpp
template<class... Ts>
class variant {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  template<class T>
  constexpr variant(T&& t)
   : index{find_index<T, Ts...>} // Powered by TMP
     // ...
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  constexpr auto visit(auto&& fn)
    -> decltype(dispatch(fn)); // Powered by TMP
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
};
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
template<class T>  decltype(auto) get(auto&& t); // Powered by TMP
template<size_t N> decltype(auto) get(auto&& t); // Powered by TMP
```
<!-- .element: class="fragment" data-fragment-index="3" -->

----

#### Don't repeat yourself (DRY) -

```cpp
constexpr auto fn(std::integral auto);
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
using integral_types = list<bool, char, char8_t, char16_t, char32_t, wchar_t, short, int, long, long long>;
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
for_each<integral_types>([]<class TIntegral> {
  static_assert(requires(TIntegral integral) { fn(integral); });
});
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### Flexibilty - generic factories -

```cpp
struct foo {
  constexpr foo(std::unique_ptr<bar>);
};
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
auto f = make<foo>(42); // Powered by TMP
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
auto f = make<foo>(overload{ // Powered by TMP
  []<std::integral> { return 42; },
});
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### API - Domain Specific Languages - https://godbolt.org/z/s9a6EW5j9

```cpp
sm connection = overload{ // Powered by TMP
 [](Disconnected, connect)    -> Connecting   { establish(); },
 [](Connecting,   established)-> Connected    { },
 [](auto,         ping e)                     { if(e.valid) reset(); },
 [](auto,         timeout)    -> Connecting   { establish(); },
 [](auto,         disconnect) -> Disconnected { close(); },
};
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
static_assert(sizeof(connection) == 1u); // Powered by TMP
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
connection.process_event(connect{}); // Disconnected -> Connecting
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
// Substitution failure is not an error (SFINAE) friendly
static_assert(not [&](const auto& event) {
  return requires {
    connection.process_event(event); // Powered by TMP
  };
}(unknown{}));
```
<!-- .element: class="fragment" data-fragment-index="3" -->

----

#### Performance - https://godbolt.org/z/o39Kh6z7b

```cpp
struct unpacked {
  short s; // size: 2 bytes, alignment:
  int i;   // size: 4 bytes, alignment:
  bool b;  // size: 1 bytes, alignment:
};
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
static_assert(12u == sizeof(unpacked));
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
template<class T>
using pack_t = pack<T>; // Powered by TMP
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
static_assert(8u == sizeof(pack_t<unpacked>));
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
static_assert(requires(pack_t<unpacked> p) { p.i; p.s; p.b; });
```
<!-- .element: class="fragment" data-fragment-index="4" -->

----

#### Performance - https://godbolt.org/z/Y7afn9x8r

```cpp
template<class T>
struct soa_vector { // Struct of Arrays
  constexpr void push_back(T&& value);      // Powered by TMP
  constexpr auto& operator[](size_t index); // Powered by TMP
  // ...
  soa_storage<T> storage{};                 // Powered by TMP
};
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
int main() {
  struct vec3 { float x, y, z; };

  soa_vector<vec3> v{};
  // soa_vector<vec3> {
  //   vector<float> x;
  //   vector<float> y;
  //   vector<float> z;
  //   void push_back(vec3 v);
  // };

  v.push_back({.x=1, .y=2, .z=3});
  assert(1 == v[0].x and
         2 == v[0].y and
         3 == v[0].z);
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### Performace - Hardware accelerated perfect hashing (reflection) -

```cpp
static constexpr array ids{
};

lookup<ids>(id); // Powered by TMP
lookup:
```

---

- https://godbolt.org/z/KcP157nYf

```cpp
  static constexpr std::array protocols{
    std::pair{"ftp"sv,  1},
    std::pair{"file"sv, 2},
    std::pair{"http"sv, 3},
    std::pair{"ws"sv,   5},
    std::pair{"wss"sv,  6},
  };

  auto lookup = mph::lookup<protocols>;
  static_assert(1 == lookup("ftp"));
  static_assert(2 == lookup("file"));
  static_assert(3 == lookup("http"));
  static_assert(5 == lookup("ws"));
  static_assert(6 == lookup("wss"));

  return lookup(str);
```

```cpp
minimal(std::basic_string_view<char, std::char_traits<char> >):
        sall    $3, %edi
        bzhi    %edi, (%rsi), %edi
        imull   $385596323, %edi, %edi
        movl    $358, %eax
        shrl    $29, %edi
        shrx    %edi, %eax, %eax
        andl    $7, %eax
        ret
```

----

## ...

----

## Template Metaprogramming (TMP)

----

#### Template Metaprogramming (TMP)

---

##### - Type based TMP ([boost.mpl](https://github.com/boostorg/mpl) -> [boost.mp11](https://github.com/boostorg/mp11), ...)
<!-- .element: class="fragment" data-fragment-index="1" style="text-align:left" -->

##### - Heterogeneous based TMP ([boost.fusion](https://github.com/boostorg/fusion) -> [boost.hana](https://github.com/boostorg/hana))
<!-- .element: class="fragment" data-fragment-index="2" style="text-align:left" -->

##### - Value based TMP (this talk -> [mp](https://github.com/qlibs/mp), [P2996](https://wg21.link/P2996), ...)
<!-- .element: class="fragment" data-fragment-index="3" style="text-align:left" -->

##### - Language feature based TMP (this talk -> [circle-lang](https://www.circle-lang.org), [zig-lang](https://ziglang.org/), ...)
<!-- .element: class="fragment" data-fragment-index="4" style="text-align:left" -->

---

##### Disclaimer: constexpr/consteval, code generation, ...
<!-- .element: class="fragment" data-fragment-index="5" style="text-align:center" -->

----

### Value based TMP

----

#### Value based TMP - pseudo code

```cpp
1. constexpr auto meta_function(const ranges::range auto& v) {
2.   std::vector<???> r; // STL containeres
3.
4.   for (const auto& e : v) {
5.     if (not std::is_const_v<???e???>) { // existing utilities (concepts, type_traits)
6.       r.push_back(???const e????);
7.     }
8.   }
1.
1.   std::reverse(r.begin(), r.end()); // STL algorithms
1.
1.   return std::views::(r) // ranges
1.     | filter ()
1.     | take(2);
1. }
```
----

#### Value based TMP - pseudo code

#### - fast-compilation

```cpp
static_assert(type_list<const int, double, float>,
           ???meta_function(vector{int, double, float}));
```

#### - informative error messages

```cpp
contexpr auto sum(auto... args) { return (args + ...); }
"sum"_test = [] {
  static_assert(sum() == 6);
};
```

```cpp
"vector"_test = [] {
  std::vector<int> v;
  static_assert(v.empty()); // error

  constexpr std::vector<int> v; // error
  static_assert(v.empty());

  std::vector<int> v; // error
  assert(v.empty()); // okay
};
```

```cpp
constexpr void expect(auto cond)
 requires requires { bool(cond); } {
  if consteval {
    if (not cond) {
      void failed(); failed(); // not constexpr
    }
  } else {
    #ifndef NDEBUG
      if (not cond) {
        std::breakpoint(); // trap
      }
    #endif
  }
}
```

```cpp
auto meta_function() {
  std::vector<info> v;
  expect(v.empty());
}

// show error message

```

#### - testing, debugging, code coverage

```cpp
"meta_function"_test = [] {
  expect(meta_function(vector{1, 2, 3}});
};
```

----

### Value based TMP - let's make it happen with C++17?

#### [clang, gcc, msvc](https://godbolt.org/z/6asb6K4EK) / [no dependencies](https://godbolt.org/z/6asb6K4EK)
<!-- .element: class="fragment" -->

----

#### Value based TMP - https://godbolt.org/z/acenYn9Ez

```cpp
1. vector<???>
```

```cpp
constexpr vector v = {1, 2, 3}; // error
constexpr auto fn() {
  vector v{1, 2, 3}; // okay
  return v;          // error (allocation)
}
constexpr auto fn() {
  array v{1, 2, 3};  // okay
  return v;          // okay
}
constexpr auto fn() {
  inplace_vector v{1, 2, 3};  // okay
  return v;          // okay
}
```

- inplace_vector - https://wg21.link/P0843
- More constexpr containers - https://wg21.link/P0784
- Non-transient constexpr allocation - https://wg21.link/P1974

```cpp
10. constexpr vector<???> v = meta_function(...);
11. using type = !!!(variant, v); // variant<Ts...>
```

---

```cpp
template<class T>
inline constexpr auto meta = &detail::meta<T>::id;
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
static_assert(meta<int> == meta<int>);
static_assert(meta<int> != meta<void>);
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
using info = decltype(meta<void>);
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
static_assert(typeid(meta<int>)  == typeid(info));
static_assert(typeid(meta<void>) == typeid(info));
static_assert(typeid(meta<int>)  == typeid(meta<void>));
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
vector<info> {meta<int>, meta<void>}; // ✔️
```

----

#### Value based TMP - https://godbolt.org/z/acenYn9Ez

```cpp
namespace detail {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  template<class T> struct meta {
    using value_type = T;
    static constexpr size_t id{};
    constexpr auto friend get(info<&id>) { return meta{}; }
  };
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  template<auto> struct info {
    constexpr auto friend get(info);
  };
```
<!-- .element: class="fragment" data-fragment-index="2" -->


```cpp
} // namespace detail
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### Value based TMP - https://godbolt.org/z/acenYn9Ez

```cpp
template<info meta>
using type_of = typename decltype(get(meta_info<meta>{}))::value_type;
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
constexpr info meta_int = meta<int>;
type_of<meta_int> i{}; // same as int i{};
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
type_of<meta<bool>> b = true; // same as bool b = true;
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### Value based TMP - https://godbolt.org/z/acenYn9Ez

```cpp
template<size_t N, class... Ts>
using at = type_of<array{meta<Ts>...}[N]>;
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
static_assert(is_same_v<int, at<0, int, bool, float>>);
static_assert(is_same_v<bool, at<1, int, bool, float>>);
static_assert(is_same_v<float, at<2, int, bool, float>>);
```
<!-- .element: class="fragment" data-fragment-index="3" -->

---

##### C++26 - Generalized pack declaration and usage - https://wg21.link/P1858
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
template<size_t N, class... Ts>
using at = Ts...[N];
```
<!-- .element: class="fragment" data-fragment-index="4" -->

----

#### Value based TMP - https://godbolt.org/z/acenYn9Ez

```cpp
template<template<class...> class T, ranges::range auto range>
using apply_t =
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  decltype(
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
    []<size_t... Ns>(index_sequence<Ns...>) {
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
      return declval<T<type_of<range[Ns]>...>>();
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
    }(make_index_sequence<range.size()>{})
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  );
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
static_assert(
  typeid(variant<int>)
  ==
  typeid(apply_t<variant, vector{meta<int>}>)
);
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### Value based TMP - https://godbolt.org/z/acenYn9Ez

```cpp
template<ranges::range auto range>
constexpr auto for_each(auto&& fn) {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  [fn]<size_t... Ns>(index_sequence<Ns...>) {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
    (fn.template operator()<range[Ns]>(), ...);
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  }(make_index_sequence<range.size()>{});
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

##### Expansion statements* - https://wg21.link/P1306
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
template for (constexpr auto r : range) {
  // ... // can return but can't break
}
```
<!-- .element: class="fragment" data-fragment-index="4" -->

---

```cpp
template<class... Ts>
constexpr auto reverse_and_drop() {
  // fusion for faster compilation times
  // do for_each
  array v{meta<Ts>...};
  size_t i = sizeof...(Ts) - 1;
  return array{v[(void((Ts*)0),i)--]...};
}
```
<!-- .element: class="fragment" data-fragment-index="5" -->

----

#### Problem

```cpp
template<class... Ts>
consteval fn() {
  vector v{meta<Ts>...};
  if (type_of<v[0]>) // error
}
```

----

#### invoke

```cpp
template<class Fn, class T = decltype([]{})>
constexpr auto invoke(Fn&& fn, info m) {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  constexpr auto dispatch = [fn]<size_t... Ns>(index_sequence<Ns...>) {
    return array{
      [](Fn&& fn) { return fn.template operator<Ns>(); }...
    };
  }(make_index_sequence<distance(meta<void>, meta<T>)>{});
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  return dispatch[distance(meta<void>, m)](fn);
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
static_assert(
  invoke(
    []<info m> { return is_const_v<type_of<m>>; },
    meta<const int>
  )
);
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### invoke

```cpp
template<template<class...> class T, class... Ts>
[[nodiscard]] constexpr auto invoke(info m) {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  return invoke([]<info meta> {
    return T<type_of<meta>, Ts...>::value;
  }, m);
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
static_assert(invoke<std::is_const>(meta<const int>));
static_assert(not invoke<std::is_reference>(meta<void*>));
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### STL/ranges - https://godbolt.org/z/GvzjvdPq8

```cpp
template<class... Ts>
struct example {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  apply_t<variant,
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
      array{meta<Ts>...}
    | views::drop(1)
    | views::reverse
    | views::filter   ([](auto m) { return invoke<is_integral>(m); })
    | views::transform([](auto m) { return invoke<add_const>(m); })
    | views::take(2)
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  > v;
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```
};
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
static_assert(
  typeid(variant<const int, const short>)
  ==
  typeid(example<double, void, const short, int>::v)
);
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### Debugging/Testing - https://godbolt.org/z/vTfGGToa4

```cpp
constexpr auto reverse(ranges::range auto v) {
  reverse(v.begin(), v.end());
  return v;
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
static_assert(
  array{meta<float>, meta<int>}
  ==
  reverse(array{meta<int>, meta<float>)
);
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
int main() {
  assert((
    array{meta<float>, meta<int>}
    ==
    reverse(array{meta<int>, meta<float>})
  ));
}
```
<!-- .element: class="fragment" data-fragment-index="2"  -->

----

#### C++26* - https://wg21.link/P2996

> Reflection for C++
<!-- .element: class="fragment" -->

----

#### C++26* - https://wg21.link/P2996

```cpp
namespace meta {
  using info = decltype(^::); // ~type-erased AST node
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  // ...
  consteval auto members_of(info) -> vector<info>;
  consteval auto enumerators_of(info) -> vector<info>;
  // ...
  consteval auto identifier_of(info) -> string_view;
  // ...
  consteval auto offset_of(info) -> member_offsets;
  consteval auto size_of(info) -> size_t;
  // ...
  consteval auto is_public(info) -> bool;
  consteval auto is_protected(info) -> bool;
  consteval auto is_private(info) -> bool;
  // ...
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### C++26* - https://wg21.link/P2996

```cpp
[:   // splicer
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
  ^T // lift
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
:]
```
<!-- .element: class="fragment" data-fragment-index="3" -->

---

```cpp
static_assert(^int == ^int);
static_assert(^int == ^void);
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
static_assert(typeid(^int)  == typeid(info));
static_assert(typeid(^void) == typeid(info));
static_assert(typeid(^int)  == typeid(^void));
```
<!-- .element: class="fragment" data-fragment-index="6" -->

----

#### C++26* - https://wg21.link/P2996

<img src="images/cmp.png" style="width: 25%; background:none; border:none; box-shadow:none;" />

```cpp
template<size_t N, class... Ts>
using at =
  typename [: array{^Ts...}[N] :]; // type_of<array{meta<Ts>...}[N]>
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
static_assert(typeid(int)   == typeid(at<0, int, float, short>));
static_assert(typeid(float) == typeid(at<1, int, float, short>));
static_assert(typeid(short) == typeid(at<2, int, float, short>));
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### C++26* - https://wg21.link/P2996

```cpp
// ranges
```

----

## Language based TMP

----

### Circle-lang - https://www.circle-lang.org

---

##### Disclaimer: Member packs, reflection, ...
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### Circle-lang - https://circle.godbolt.org/z/sqsaKvqar

// at example

// slicing example

// rotate

// reflection

// ranges

```cpp
template<class...> struct type_list{};
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
template<class... Ts>
auto rotate = type_list<Ts.rotate(1)...>{};
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
static_assert(
  typeid(rotate<int, double, float>)
  ==
  typeid(type_list<double, float, int>)
);
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### Circle-lang - https://circle.godbolt.org/z/TdPYzxMc1

// cricle classic @keyword

```cpp
template<class... Ts>
struct example {
 variant<Ts...[-2::-1]...> v; // python-like slicing
};
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
static_assert(
  typeid(example<int, double, float>::v)
  ==
  typeid(variant<double, int>)
);
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

### Benchmarks

----

#### Compilation-times benchmark - https://qlibs.github.io/mp

<a href="https://qlibs.github.io/mp"><img src="images/bench.png" style="width: 100%; background:none; border:none; box-shadow:none;" /></a>

----

### Summary

* #### Metaprogramming is C++ superpower and can be used to enhance performance, design, ...
<!-- .element: class="fragment" -->

* #### Metaprogramming doesn't have to be different than run-time programming
<!-- .element: class="fragment" -->

* #### Reflection enhances metaprogramming use-cases
<!-- .element: class="fragment" -->

----

### Further readings

- ##### Metaprogramming library - https://github.com/qlibs/mp
<!-- .element: style="text-align:left" -->

- ##### Reflection for C++ - https://wg21.link/P2996
<!-- .element: style="text-align:left" -->

- ##### Circle-lang Metaprogramming - Sean Baxter - CppNow 2022  - https://www.youtube.com/watch?v=15j4bkipuAg
<!-- .element: style="text-align:left" -->

- ##### Simple C++11 metaprogramming - Peter Dimov - https://www.boost.org/doc/libs/master/libs/mp11/doc/html/simple_cxx11_metaprogramming.html
<!-- .element: style="text-align:left" -->

- ##### Implementing P2996 metaprogramming model with P2996 - https://godbolt.org/z/694e1hrbM

---

##### [kris@jusiak.net](mailto:kris@jusiak.net) | [@krisjusiak](https://twitter.com/krisjusiak) | [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)
          </script>
        </section>

      </div>
    </div>

    <script src="reveal.js/lib/js/head.min.js"></script>
    <script src="reveal.js/js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({

        // Display controls in the bottom right corner
        controls: false,

        // Display a presentation progress bar
        progress: false,

        // Display the page number of the current slide
        slideNumber: 'c/t',

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // Hides the address bar on mobile devices
        hideAddressBar: true,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style
        transition: 'none', // none/fade/slide/convex/concave/zoom

        // Transition speed
        transitionSpeed: 'default', // default/fast/slow

        // Transition style for full page slide backgrounds
        backgroundTransition: 'none', // none/fade/slide/convex/concave/zoom

        // Number of slides away from the current that are visible
        viewDistance: 1,

        // Parallax background image
        parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // Parallax background size
        parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

        // Number of pixels to move the parallax background per slide
        // - Calculated automatically unless specified
        // - Set to 0 to disable movement along an axis
        parallaxBackgroundHorizontal: null,
        parallaxBackgroundVertical: null,

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true },
          { src: 'extensions/plugin/line-numbers/line-numbers.js' }
        ]
      });

      function handleClick(e) {
        if (1 >= outerHeight - innerHeight) {
          document.querySelector( '.reveal' ).style.cursor = 'none';
        } else {
          document.querySelector( '.reveal' ).style.cursor = '';
        }

        e.preventDefault();
        if(e.button === 0) Reveal.next();
        if(e.button === 2) Reveal.prev();
      }
    </script>

  </body>
</html>
