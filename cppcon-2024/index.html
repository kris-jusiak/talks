<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Template-less Metaprogramming</title>

    <link rel="stylesheet" href="reveal.js/css/reveal.css">
    <link rel="stylesheet" href="reveal.js/css/theme/league.css" id="theme">
    <link rel="stylesheet" href="extensions/plugin/line-numbers/line-numbers.css">
    <link rel="stylesheet" href="extensions/css/highlight-styles/zenburn.css">
    <link rel="stylesheet" href="extensions/css/custom.css">

    <style>
      .reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5 { text-transform: none; }
    </style>

    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );

      function set_address(self, remote, local) {
        if (window.location.search.match("local")) {
          self.href = local;
        } else {
          self.href = remote;
        }
      }
    </script>

    <meta name="description" content="Compile-time reflections">
    <meta name="author" content="Kris Jusiak">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
          <script type="text/template">
          </script>
          </section>

          <section data-markdown=""
                   data-separator="^====+$"
                   data-separator-vertical="^----+$">
          <script type="text/template">
<!-- .element: data-background-image="images/title_card.png"  data-background-size="100%"  -->

<br />&nbsp;
<br />&nbsp;
<br />&nbsp;
<br />&nbsp;
<br />&nbsp;
<br />&nbsp;
<br />&nbsp;
<img src="images/qr.png" style="width: 15%; background:none; border:none; box-shadow:none;" />

----

#### Agenda

- #### Motivation
<!-- .element: class="fragment" -->
  - #### Examples
<!-- .element: class="fragment" -->

- #### Template Metaprogramming (TMP)
<!-- .element: class="fragment" -->

  - #### Approches / Implementation
  <!-- .element: class="fragment" -->

  - #### Benchmarks
  <!-- .element: class="fragment" -->

- #### Summary
<!-- .element: class="fragment" -->

---

###### Powered by [Compiler Explorer](https://godbolt.org)
<!-- .element: class="fragment" -->

----

#### Template Metaprogramming (TMP)
> ```cpp
template<class... Ts>
using meta_fn = this_talk<Ts...>; // types
```
<!-- .element: class="fragment" data-fragment-index="0" style="text-align:center" -->

#### Compile-time computations
<!-- .element: class="fragment" data-fragment-index="1" style="text-align:center" -->
> ```cpp
constexpr auto used_in_this_talk(
  std::integral auto... vs); // values
```
<!-- .element: class="fragment" data-fragment-index="1" style="text-align:center" -->

#### Code generation
<!-- .element: class="fragment" data-fragment-index="2" style="text-align:center" -->
> ```cpp
$ gperf keywords.txt >
    not_used_after_this_talk.cpp // files
```
<!-- .element: class="fragment" data-fragment-index="2" style="text-align:center" -->

----

### Motivation / Examples

> ##### `"Better Metaprogramming features make better libraries!"`
> ###### `Sean Baxter `
<!-- .element: class="fragment" -->

----

#### [Examples] Standard Template Library (STL)

```cpp
template<class... Ts>
template<class T>
constexpr variant<Ts...>::variant(T&& t)
 : index{find_index<T, Ts...>} // Powered by TMP
 , // ...
{ }
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
template<size_t I, class... Ts>
constexpr auto get(tuple<Types...>&&) noexcept ->
  typename tuple_element<I, tuple<Ts...>>::type&&; // Powered by TMP
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
template<class TFirst, class... TRest>
array(TFirst, TRest...) -> array<
  typename Enforce_same<TFirst, TRest...>::type, // Powered by TMP
  1 + sizeof...(TRest)
>;
```
<!-- .element: class="fragment" data-fragment-index="2" -->

### ...
<!-- .element: class="fragment" data-fragment-index="3" style="text-align:left" -->

----

### Standard Template Library (STL) doesn't have Standard Template Metaprogramming library

----

#### [Examples] Performance

```cpp
struct unpacked {
  short s; // size: 2 bytes, alignment:
  int i;   // size: 4 bytes, alignment:
  bool b;  // size: 1 bytes, alignment:
};
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
static_assert(12u == sizeof(unpacked));
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
template<class T>
using pack_t = /*...*/; // Powered by TMP
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
static_assert(8u == sizeof(pack_t<unpacked>));
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
static_assert(
  requires(pack_t<unpacked> p) {
    p.s;
    p.i;
    p.b;
  }
);
```
<!-- .element: class="fragment" data-fragment-index="4" -->

----

#### [Examples] Performance

```cpp
struct vec3 { float x, y, z; };
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
template<class T>  // Struct of Arrays
struct soa_vector; // Powered by TMP
```
<!-- .element: class="fragment" data-fragment-index="1" -->


```cpp
int main() {
  v.push_back({.x=1, .y=2, .z=3});
  assert(1 == v[0].x and 2 == v[0].y and 3 == v[0].z);
}
```
<!-- .element: class="fragment" data-fragment-index="2" -->

---

```cpp
vector<vec3>     // {x, y, z},       {x, y, z},       {x, y, z}...
soa_vector<vec3> // {x, x, x}, ... | {y, y, y}, ... | {z, z, z}, ...
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### [Examples] Performance

```cpp
auto enum_to_string(Enum auto value) -> std::string_view;
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
template<Enum> auto string_to_enum(std::string_view);
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### [Examples] Domain Specific Languages (DSL)

```cpp
struct Disconnected { };
struct Connecting   { };
struct Connected    { };
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
sm connection = overload{
 [](Disconnected, connect)     -> Connecting   { establish(); },
 [](Connecting,   established) -> Connected    { },
 [](auto,         ping e)                      { if (not e) reset(); },
 [](Connecting,   auto)        -> Connecting   { establish(); },
 [](auto,         disconnect)  -> Disconnected { close(); },
 [](auto,         auto)        -> Error        { },
};
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
static_assert(sizeof(connection) == 1u); // Powered by TMP
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

# ...
### https://github.com/boostorg
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### [History] Template Metaprogramming

---

##### - Type based TMP ([boost.mpl](https://github.com/boostorg/mpl) -> [boost.mp11](https://github.com/boostorg/mp11), ...)
<!-- .element: class="fragment" data-fragment-index="1" style="text-align:left" -->

##### - Heterogeneous based TMP ([boost.fusion](https://github.com/boostorg/fusion) -> [boost.hana](https://github.com/boostorg/hana))
<!-- .element: class="fragment" data-fragment-index="2" style="text-align:left" -->

##### - Value based TMP (this_talk -> [mp](https://github.com/qlibs/mp), [https://wg21.link/P2996](https://wg21.link/P2996), ...)
<!-- .element: class="fragment" data-fragment-index="3" style="text-align:left" -->

---

##### - Language based TMP (this_talk -> [circle-lang](https://www.circle-lang.org), [zig-lang](https://ziglang.org/), ...)
<!-- .element: class="fragment" data-fragment-index="4" style="text-align:left" -->

----

### Value based TMP

##### By Example
<!-- .element: class="fragment" -->

----

### Let's start simple...

----

#### Value based TMP - find_index

```cpp
template<class T, class... Ts>
constexpr auto find_index() -> std::size_t;
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
static_assert(0u == find_index<int,  int,   float, short>());
static_assert(1u == find_index<int,  float, int,   short>());
static_assert(2u == find_index<int,  float, short, int>());
static_assert(3u == find_index<void, float, short, int>());
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### Value based TMP - find_index (pseudo code)

```cpp
template<class T, class... Ts>
constexpr auto find_index() -> std::size_t {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  std::array ts{???<Ts>...};
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  for (auto i = 0u; i < ts.size(); ++i) {
    if (ts[i] == ???<T>) {
      return i;
    }
  }
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  return ts.size();
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### Value based TMP - ???
<!-- .element: style="text-align:left" -->

```cpp
std::array ts{???<int>, ???<void>};
```
<!-- .element: class="fragment" style="text-align:left" -->

```cpp
static_assert(???<int>) == ???<int>));
static_assert(???<int>) != ???<void>));
static_assert(typeid(???<int>) == typeid(???<void>));
```
<!-- .element: class="fragment" style="text-align:left" -->

#### Let's replace ??? with meta
<!-- .element: class="fragment" style="text-align:left" -->

```cpp
std::array ts{meta<int>, meta<void>};
```
<!-- .element: class="fragment" style="text-align:left" -->

```cpp
static_assert(meta<int>) == meta<int>));
static_assert(meta<int>) != meta<void>));
static_assert(typeid(meta<int>) == typeid(meta<void>));
```
<!-- .element: class="fragment" style="text-align:left" -->

----

#### Value based TMP - meta
<!-- .element: style="text-align:left" -->

```cpp
template<class T> struct type {
  static constexpr std::size_t id{};
};
```
<!-- .element: class="fragment" data-fragment-index="1" style="text-align:left" -->

```cpp
template<class T>
inline constexpr auto meta = &type<T>::id;
```
<!-- .element: class="fragment" data-fragment-index="0" style="text-align:left" -->

---

```cpp
static_assert(meta<int>) == meta<int>));                // ✔️
static_assert(meta<int>) != meta<void>));               // ✔️
static_assert(typeid(meta<int>) == typeid(meta<void>)); // ✔️
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
std::array ts{meta<int>, meta<void>};                   // ✔️
```
<!-- .element: class="fragment" data-fragment-index="3" -->

----

#### Value based TMP - find_index - https://godbolt.org/z/acenYn9Ez

```cpp
template<class T, class... Ts>
constexpr auto find_index() -> std::size_t {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  std::array ts{meta<Ts>...};
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  for (auto i = 0u; i < ts.size(); ++i) {
    if (ts[i] == meta<T>) {
      return i;
    }
  }
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  return ts.size();
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
static_assert(0u == find_index<int,  int,   float, short>()); // ✔️
static_assert(1u == find_index<int,  float, int,   short>()); // ✔️
static_assert(2u == find_index<int,  float, short, int>());   // ✔️
static_assert(3u == find_index<void, float, short, int>());   // ✔️
```
<!-- .element: class="fragment" data-fragment-index="4" -->

----

#### Value based TMP - find_index - template-less refactor

```cpp
constexpr auto find_index(auto t, const range auto& v) -> std::size_t {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  for (auto i = 0u; i < v.size(); ++i) {
    if (v[i] == t) {
      return i;
    }
  }
  return v.size();
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
static_assert(0u == find_index(
  meta<int>, std::array{meta<int>, meta<float>, meta<short>}
)); // ✔️
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
static_assert(2u == find_index(
  42, std::array{1, 2, 42, 3}
)); // ✔️
```
<!-- .element: class="fragment" data-fragment-index="3" -->

----

#### Value based TMP - find_index - no raw loops refactor

```cpp
constexpr auto find_index(auto t, const range auto& v) -> std::size_t {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  if (auto found = std::ranges::find(v, t); found) {
    return std::distance(v.begin(), found);
  }
  return v.size();
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
static_assert(0u == find_index(
  meta<int>, std::array{meta<int>, meta<float>, meta<short>}
)); // ✔️

static_assert(3u == find_index(
  meta<void>, std::array{meta<int>, meta<float>, meta<short>}
)); // ✔️
```
<!-- .element: class="fragment" data-fragment-index="2" -->

-----

#### Value based TMP - tuple_element (pseudo code)

```cpp
template<std::size_t I, class... Ts>
struct tuple_element<I, std::tuple<Ts...>> {
  using type = ???<I, T>;
};
```
<!-- .element: class="fragment" data-fragment-index="3" -->

---

```cpp
static_assert(
  std::is_same_v<int,   tuple_element<0, int, bool, float>::type> and
  std::is_same_v<bool,  tuple_element<1, int, bool, float>::type> and
  std::is_same_v<float, tuple_element<2, int, bool, float>::type>
);
```
<!-- .element: class="fragment" data-fragment-index="3" -->

----

#### Value based TMP - ???
<!-- .element: style="text-align:left" -->

```cpp
std::array{meta<Ts>...} // {meta<int>, meta<bool>, meta<float>}
```
<!-- .element: class="fragment" data-fragment-index="0" style="text-align:left" -->

```cpp
std::array{meta<Ts>...}[1] // meta<bool>
```
<!-- .element: class="fragment" data-fragment-index="1" style="text-align:left" -->

```cpp
type_of<std::array{meta<Ts>...}[I]> // bool
```
<!-- .element: class="fragment" data-fragment-index="2" style="text-align:left" -->

----

#### Value based TMP - type_of

```cpp
template<auto> struct info { constexpr auto friend get(info); };
```
<!-- .element: class="fragment" data-fragment-index="1" style="text-align:left" -->

```cpp
template<class T> struct type {
  static constexpr std::size_t id{};
```
<!-- .element: class="fragment" data-fragment-index="0" style="text-align:left" -->

```cpp
  using value_type = T;
  constexpr auto friend get(info<&id>) { return type{}; }
```
<!-- .element: class="fragment" data-fragment-index="1" style="text-align:left" -->

```cpp
};
```
<!-- .element: class="fragment" data-fragment-index="0" style="text-align:left" -->

---

```cpp
constexpr auto int_type_id = &type<int>::id;
static_assert(std::is_same_v<type<int>, get(info<int_type_id>)));
```
<!-- .element: class="fragment" data-fragment-index="2" style="text-align:left" -->

----

#### Value based TMP - type_of


```cpp
template<auto meta>
using type_of = typename decltype(get(info<meta>{}))::value_type;
```
<!-- .element: class="fragment" data-fragment-index="0" style="text-align:left" -->

---

```cpp
type_of<meta<int>> b = true; // bool b = true;
type_of<meta<int>> i = 42;   // int i = 42;
```
<!-- .element: class="fragment" data-fragment-index="2" style="text-align:left" -->

----

#### Value based TMP - tuple_element

```cpp
template<std::size_t I, class... Ts>
struct tuple_element<I, std::tuple<Ts...>> {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  using type = type_of<std::array{meta<Ts>...}[N]>
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
};
```
<!-- .element: class="fragment" data-fragment-index="0" style="text-align:left" -->

```cpp
static_assert(
  std::is_same_v<int,   tuple_element<0, int, bool, float>::type> and
  std::is_same_v<bool,  tuple_element<1, int, bool, float>::type> and
  std::is_same_v<float, tuple_element<2, int, bool, float>::type>
); // ✔️
```
<!-- .element: class="fragment" data-fragment-index="3" -->

---

##### C++26 - Pack indexing - https://wg21.link/p2662
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
template<std::size_t I, class... Ts>
struct tuple_element<I, std::tuple<Ts...>> {
  using type = Ts...[I];
};
```
<!-- .element: class="fragment" data-fragment-index="4" -->

----


### Let's make it a bit more interesting...

----

#### Value based TMP -

```cpp
constexpr auto meta_fn(const ranges::range auto& v) {
  std::vector<???> r; // STL containers

  for (const auto& e : v) {
    if (not std::is_const_v<e>) {
      r.push_back(std::pair{e, e});
    }
  }

  std::rotate(r.begin(), r.end()); // STL algorithms

  return std::views::(r) // ranges
    | filter ()
    | take(2);
}
```

---

```cpp
static_assert();
```

----

```cpp
using info = decltype(meta<void>);
```
<!-- .element: class="fragment" data-fragment-index="2" -->

#### Value based TMP - https://godbolt.org/z/acenYn9Ez

```cpp
template<template<class...> class T, ranges::range auto range>
using apply_t =
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  decltype(
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
    []<size_t... Ns>(index_sequence<Ns...>) {
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
      return declval<T<type_of<range[Ns]>...>>();
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
    }(make_index_sequence<range.size()>{})
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  );
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
static_assert(
  typeid(variant<int>)
  ==
  typeid(apply_t<variant, vector{meta<int>}>)
);
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----


filter to introduce invoke and ranges


COVERAGE - we need testig at compile time and run-time! show ut technique

----

----

#### Value based TMP - pseudo code

#### - fast-compilation

```cpp
static_assert(type_list<const int, double, float>,
           ???meta_function(vector{int, double, float}));
```

#### - informative error messages

```cpp
contexpr auto sum(auto... args) { return (args + ...); }
"sum"_test = [] {
  static_assert(sum() == 6);
};
```

```cpp
"vector"_test = [] {
  std::vector<int> v;
  static_assert(v.empty()); // error

  constexpr std::vector<int> v; // error
  static_assert(v.empty());

  std::vector<int> v; // error
  assert(v.empty()); // okay
};
```

```cpp
constexpr void expect(auto cond)
 requires requires { bool(cond); } {
  if consteval {
    if (not cond) {
      void failed(); failed(); // not constexpr
    }
  } else {
    #ifndef NDEBUG
      if (not cond) {
        std::breakpoint(); // trap
      }
    #endif
  }
}
```

```cpp
auto meta_function() {
  std::vector<info> v;
  expect(v.empty());
}

// show error message
#### - testing, debugging, code coverage

---

#### invoke

```cpp
template<class Fn, class T = decltype([]{})>
constexpr auto invoke(Fn&& fn, info m) {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  constexpr auto dispatch = [fn]<std::size_t... Ns>(std::index_sequence<Ns...>) {
    return std::array{
      [](Fn&& fn) { return fn.template operator<Ns>(); }...
    };
  }(make_index_sequence<std::distance(meta<void>, meta<T>)>{});
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  return dispatch[std::distance(meta<void>, m)](fn);
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
static_assert(
  invoke(
    []<info m> { return is_const_v<type_of<m>>; },
    meta<const int>
  )
);
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### invoke

```cpp
template<template<class...> class T, class... Ts>
[[nodiscard]] constexpr auto invoke(info m) {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  return invoke([]<info meta> {
    return T<type_of<meta>, Ts...>::value;
  }, m);
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
static_assert(invoke<std::is_const>(meta<const int>));
static_assert(not invoke<std::is_reference>(meta<void*>));
```
<!-- .element: class="fragment" data-fragment-index="0" -->


```cpp
```

----

### https://godbolt.org/z/E77EK5je9

```cpp
C++17 (~100 LOC) - ✔️         easy testing     - ✔️
clang, gcc, msvc - ✔️         easy debugging   - ✔️
no dependencies  - ✔️         coverage support - ✔️
'normal' C++     - ✔️         improved errors  - ✔️
```

----

### Reflection for C++26* - https://wg21.link/P2996

---

##### 2 new operators
<!-- .element: class="fragment" style="text-align:left" -->
##### Value based Metaprogramming
<!-- .element: class="fragment" style="text-align:left" -->
##### Meta functions for Reflection
<!-- .element: class="fragment" style="text-align:left" -->

----

#### Reflection for C++26* - https://wg21.link/P2996

```cpp
^T // lift
```
<!-- .element: class="fragment" -->

```cpp
static_assert(^int == ^int);
static_assert(^int != ^void);
```
<!-- .element: class="fragment" -->

```cpp
static_assert(typeid(^int) == typeid(^void));
```
<!-- .element: class="fragment" -->

---

```cpp
[: info :] // splicer
```
<!-- .element: class="fragment" -->

```cpp
typename [: ^int :] i = 42; // int i = 42;
```
<!-- .element: class="fragment" -->

```cpp
static_assert(typeid([: ^int :]) == typeid(int));
```
<!-- .element: class="fragment" -->

----

#### Reflection for C++26* - https://wg21.link/P2996

```cpp
 this_talk (C++17)           | P2996 (C++26*)
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
 meta<T>                     | ^T // lift (reflexpr)
```
<!-- .element: class="fragment" data-fragment-index="2" -->
```cpp
 using info = meta<void>     | using info = decltype(^::)
```
<!-- .element: class="fragment" data-fragment-index="3" -->
```cpp
 type_of<T>                  | typename [: T :] // splicer (unreflexpr)
```
<!-- .element: class="fragment" data-fragment-index="4" -->
```cpp
 apply_t                     | substitute
```
<!-- .element: class="fragment" data-fragment-index="5" -->
```cpp
 invoke                      | reflect_invoke, test_trait, extract
```
<!-- .element: class="fragment" data-fragment-index="6" -->

---

```cpp
 not_this_talk_but_possible* | members_of, enumerators_of, bases_of,
 (C++20)                     | identifier_of, is_private, ...
```
<!-- .element: class="fragment" data-fragment-index="7" -->

----

#### Reflection for C++26* - https://wg21.link/P2996


```cpp
constexpr auto find_index(auto t, const range auto& v) -> std::size_t {
  if (auto found = std::ranges::find(v, t); found) {
    return std::distance(v.begin(), found);
  }
  return v.size();
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
static_assert(
  0u == find_index(^int,   std::array{^int, ^float, ^short}) and
  1u == find_index(^float, std::array{^int, ^float, ^short}) and
  2u == find_index(^short, std::array{^int, ^float, ^short}) and
  3u == find_index(^void,  std::array{^int, ^float, ^short})
); // ✔️
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### Reflection for C++26* - https://wg21.link/P2996

```cpp
template<std::size_t I, class... Ts>
struct tuple_element<I, std::tuple<Ts...>> {
  using type = typename [: array{^Ts...}[N] :];
};
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
static_assert(
  std::is_same_v<int,   tuple_element<0, int, bool, float>::type> and
  std::is_same_v<bool,  tuple_element<1, int, bool, float>::type> and
  std::is_same_v<float, tuple_element<2, int, bool, float>::type>
);
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### C++26* - https://wg21.link/P2996

```cpp

```
<!-- .element: class="fragment" -->

```cpp
// ranges
```

----

## Language based TMP

----

### Circle-lang - https://www.circle-lang.org

---

##### Member packs - https://wg21.link/P1858
<!-- .element: class="fragment" style="text-align:left" -->

##### Meta functions
<!-- .element: class="fragment" style="text-align:left" -->

##### Reflection
<!-- .element: class="fragment" style="text-align:left" -->

##### ...
<!-- .element: class="fragment" style="text-align:left" -->

----

#### Circle-lang - https://circle.godbolt.org/z/sqsaKvqar

```cpp
template<class T, class... Ts>
constexpr auto find_index() {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  return T == Ts... ?? int... : sizeof...(Ts); // constexpr conditional ?? :
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
template<class T, class... Ts>
constexpr auto find_index() {
  return Ts.count(T) ?? Ts.find(T) : sizeof...(Ts);
}
```
<!-- .element: class="fragment" data-fragment-index="2" -->

---

```cpp
static_assert(0u == find_index<int, int, float, short>());
static_assert(1u == find_index<int, float, int, short>());
static_assert(2u == find_index<int, float, short, int>());
static_assert(3u == find_index<void, float, short, int>());
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### Circle-lang - https://circle.godbolt.org/z/sqsaKvqar

```cpp
template<std::size_t I, class... Ts>
struct tuple_element<I, std::tuple<Ts...>> {
  using type = Ts...[I];
};
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
static_assert(
  std::is_same_v<int,   tuple_element<0, int, bool, float>::type> and
  std::is_same_v<bool,  tuple_element<1, int, bool, float>::type> and
  std::is_same_v<float, tuple_element<2, int, bool, float>::type>
);
```
<!-- .element: class="fragment" data-fragment-index="0" -->

#### Generalized pack declaration and usage - https://wg21.link/P1858
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
[2::-1]
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

### Compilation-times Benchmarks

----

screenshots

----

#### Compilation-times benchmark - https://qlibs.github.io/mp

<a href="https://qlibs.github.io/mp"><img src="images/bench.png" style="width: 50%; background:none; border:none; box-shadow:none;" /></a>

* #### Language based Metaprogramming is the fastest (https://www.circle-lang.org)
<!-- .element: class="fragment" -->

* #### Value based Metaprogramming can be as fast as Type based Metaprogramming
<!-- .element: class="fragment" -->

* #### Value based Metaprogramming with STL/Ranges is significantly slower than with raw primitives
<!-- .element: class="fragment" -->

----

### Summary

* #### Better metaprogramming features make better libraries
<!-- .element: class="fragment" -->

* #### Metaprogramming is C++ superpower and can be used to enhance design, performance, ...
<!-- .element: class="fragment" -->

* #### Metaprogramming doesn't have to be different than run-time programming (Value based TMP)
<!-- .element: class="fragment" -->

* #### Reflection enhances Metaprogramming use cases
<!-- .element: class="fragment" -->

----

### Further readings

- ##### C++17 Metaprogramming library - https://github.com/qlibs/mp
<!-- .element: style="text-align:left" -->

- ##### C++20 Reflection library - https://github.com/qlibs/reflect
<!-- .element: style="text-align:left" -->

- ##### Reflection for C++26* - https://wg21.link/P2996
<!-- .element: style="text-align:left" -->

- ##### Circle-lang Metaprogramming - Sean Baxter - CppNow 2022 - https://www.youtube.com/watch?v=15j4bkipuAg
<!-- .element: style="text-align:left" -->

- ##### Simple C++11 Metaprogramming - Peter Dimov - https://www.boost.org/doc/libs/master/libs/mp11/doc/html/simple_cxx11_metaprogramming.html
<!-- .element: style="text-align:left" -->

- ##### Implementing P2996 Metaprogramming model with P2996 - https://godbolt.org/z/694e1hrbM

---

##### [kris@jusiak.net](mailto:kris@jusiak.net) | [@krisjusiak](https://twitter.com/krisjusiak) | [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)
          </script>
        </section>

      </div>
    </div>

    <script src="reveal.js/lib/js/head.min.js"></script>
    <script src="reveal.js/js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({

        // Display controls in the bottom right corner
        controls: false,

        // Display a presentation progress bar
        progress: false,

        // Display the page number of the current slide
        slideNumber: 'c/t',

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // Hides the address bar on mobile devices
        hideAddressBar: true,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style
        transition: 'none', // none/fade/slide/convex/concave/zoom

        // Transition speed
        transitionSpeed: 'default', // default/fast/slow

        // Transition style for full page slide backgrounds
        backgroundTransition: 'none', // none/fade/slide/convex/concave/zoom

        // Number of slides away from the current that are visible
        viewDistance: 1,

        // Parallax background image
        parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // Parallax background size
        parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

        // Number of pixels to move the parallax background per slide
        // - Calculated automatically unless specified
        // - Set to 0 to disable movement along an axis
        parallaxBackgroundHorizontal: null,
        parallaxBackgroundVertical: null,

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true },
          { src: 'extensions/plugin/line-numbers/line-numbers.js' }
        ]
      });

      function handleClick(e) {
        if (1 >= outerHeight - innerHeight) {
          document.querySelector( '.reveal' ).style.cursor = 'none';
        } else {
          document.querySelector( '.reveal' ).style.cursor = '';
        }

        e.preventDefault();
        if(e.button === 0) Reveal.next();
        if(e.button === 2) Reveal.prev();
      }
    </script>

  </body>
</html>
