<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Embedding reflections</title>

    <link rel="stylesheet" href="reveal.js/css/reveal.css">
    <link rel="stylesheet" href="reveal.js/css/theme/league.css" id="theme">
    <link rel="stylesheet" href="extensions/plugin/line-numbers/line-numbers.css">
    <link rel="stylesheet" href="extensions/css/highlight-styles/zenburn.css">
    <link rel="stylesheet" href="extensions/css/custom.css">

    <style>
      .reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5 { text-transform: none; }
    </style>

    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );

      function set_address(self, remote, local) {
        if (window.location.search.match("local")) {
          self.href = local;
        } else {
          self.href = remote;
        }
      }
    </script>

    <meta name="description" content="~~Template~~ Meta-Programming">
    <meta name="author" content="Kris Jusiak">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
          <script type="text/template">
          </script>
          </section>

          <section data-markdown=""
                   data-separator="^====+$"
                   data-separator-vertical="^----+$">
          <script type="text/template">
<img src="images/embo.png" style="width: 20%; background:none; border:none; box-shadow:none;" />

---

## Embedding reflections

<img src="images/qr.png" style="width: 10%; background:none; border:none; box-shadow:none;" />

---

###### [kris@jusiak.net](mailto:kris@jusiak.net) | [@krisjusiak](https://twitter.com/krisjusiak) | [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)

----

#### Agenda
* #### Motivation
<!-- .element: class="fragment" -->

* #### Reflection
<!-- .element: class="fragment" -->

  * #### Examples
  <!-- .element: class="fragment" -->

* #### Case study
<!-- .element: class="fragment" -->

  * #### Name of enum
  <!-- .element: class="fragment" -->

* #### Summary
<!-- .element: class="fragment" -->

---

###### Powered by [Compiler Explorer](https://godbolt.org)
<!-- .element: class="fragment" -->

----

##### Motivation

- ##### Correctness/safety
<!-- .element: class="fragment" -->

  - ##### Safe APIs, checks against the spec
<!-- .element: class="fragment" -->

- ##### Performance
<!-- .element: class="fragment" -->

  - ##### Design by introspection (move conditions to compile-time)
  <!-- .element: class="fragment" -->

    ##### `if constexpr (requires { ... })`
<!-- .element: class="fragment" -->

  - ##### Injection (code generation)
  <!-- .element: class="fragment" -->

      ##### `switch { ... }`, `pack(T)`, ...
  <!-- .element: class="fragment" -->

- ##### Maintability/Flexibility/Debuggability
<!-- .element: class="fragment" -->

  ##### `serialize(T)`, `log(T)`, ...
<!-- .element: class="fragment" -->

----

##### Reflection

- ##### What?
  - ##### Introspection (dynamic:run-time, static:compile-time)
<!-- .element: class="fragment" -->
      - ##### get enum name, get members of a struct
<!-- .element: class="fragment" -->
      - ##### find all functions in the namespace
<!-- .element: class="fragment" -->
      - ##### ...
<!-- .element: class="fragment" -->

  - ##### Injection/Code generation
<!-- .element: class="fragment" -->
      - ##### convert array of structs to struct of arrays
<!-- .element: class="fragment" -->
      - ##### generate switch case
<!-- .element: class="fragment" -->
      - ##### ...
<!-- .element: class="fragment" -->

----

##### Reflection

- ##### How?

  - ##### code generation (libclang + cmake)
<!-- .element: class="fragment" -->

  - ##### compiler hacks (`__PRETTY_FUNCTION__`, friend injection)
<!-- .element: class="fragment" -->

  - ##### compiler builtins (`__builtin_dump_struct` - clang)
<!-- .element: class="fragment" -->

  - ##### compilers with reflection (https://www.circle-lang.org)
<!-- .element: class="fragment" -->

  - ##### language support
<!-- .element: class="fragment" -->
    - ##### C++2X - meta-classes (https://github.com/hsutter/cppfront)
<!-- .element: class="fragment" -->
    - ##### C++2X - mirror (https://wg21.link/P0385)
<!-- .element: class="fragment" -->
    - ##### C++26* - static reflection (https://wg21.link/P2996)
<!-- .element: class="fragment" -->

----

##### Reflection for C++26 (https://wg21.link/P2996)

- ##### Value based
<!-- .element: class="fragment" -->
    ```
      ^T                // lift (reflexpr)
      | std::meta::info // AST info
      | [: ... :]       // splicer (unreflexpr)
      ;
    ```
<!-- .element: class="fragment" -->

- ##### `consteval` based (harder to test as no lowering to run-time)
<!-- .element: class="fragment" -->

- ##### Template Meta-Programming included
<!-- .element: class="fragment" -->
  ```cpp
  static_assert(
    [: std::meta::substitute(^type_list,  // consteval
        std::vector{^int, ^float}         // std::vector{meta::info}
      | std::views::reverse               // stl::ranges
      | std::views::drop(1)
    ) :] == type_list<float>);
  ```
  <!-- .element: class="fragment" -->

  - ##### Possible in C++20 (https://github.com/boost-ext/mp)
  <!-- .element: class="fragment" -->

----

#### C++26 - introspection - https://godbolt.org/z/564szqv6M

```cpp
struct foo { char a; int b; float c; };
```
<!-- .element: class="fragment" -->

---

```cpp
static_assert(reflect<foo> == // see godbolt for implementation
  std::array{
    info{.name = "a", .size = 1, .offset = 0, .alignment = 1},
    info{.name = "b", .size = 4, .offset = 4, .alignment = 4},
    info{.name = "c", .size = 4, .offset = 8, .alignment = 4},
  }
);
```
<!-- .element: class="fragment" -->

##### Possible in C++20 (https://github.com/boost-ext/reflect)
<!-- .element: class="fragment" -->

----

#### C++26 - introspection

```cpp
^:: // error (reflecting global namespace)
```
<!-- .element: class="fragment" -->

---

##### [2024/03] P2996 doesn't support reflecting namespaces yet
<!-- .element: class="fragment" -->

----

#### C23 - introspection - #embed (https://wg21.link/P1967)

```cpp
struct foo {};
struct bar {};
auto fn() -> void;
```
<!-- .element: class="fragment" -->

---

```cpp
static_assert(not meta_contains<"struct x">);
static_assert(not meta_contains<"STD::string_view">);
static_assert(meta_contains<"std::string_view">);
static_assert(meta_contains<"struct foo">);
static_assert(meta_contains<"struct bar">);
static_assert(meta_contains<"auto fn()">);
```
<!-- .element: class="fragment" -->

---

```cpp
template<fixed_string Name> // #embed is C23 and not C++23
constexpr auto meta_contains = [] {
  static constexpr char self[] = { #embed __FILE__ };
  const auto code = std::string_view(std::data(self), std::size(self));
  const auto find = code.find(Name);
  return find != std::string_view::npos and code[find-1] != '\"';
}();
```
<!-- .element: class="fragment" -->

##### Possible but not advised!
<!-- .element: class="fragment" -->

----

#### C++26 - injection - https://godbolt.org/z/ExYfTv4nK

```cpp
struct unpacked { short s; int i; bool b; };

static_assert(12 == sizeof(unpacked));
```
<!-- .element: class="fragment" -->

---

```cpp
using packed = pack<unpacked>; // see godbolt for implementation

static_assert(8 == sizeof(packed));
static_assert(requires(packed p) { p.i; p.s; p.b; });
```
<!-- .element: class="fragment" -->

##### Possible in C++11+ but will return a std::tuple instead of new struct
<!-- .element: class="fragment" -->

----

#### C++26 - injection - https://godbolt.org/z/d7GrW1j76

```cpp
// compile-time counter
static_assert(next() == 0);
static_assert(next() == 1);
```
<!-- .element: class="fragment" -->

---

```cpp
// compile-time type list
static_assert(typeid(get_list_t<>) == typeid(type_list<>));

append_t<int>();
static_assert(typeid(get_list_t<>) == typeid(type_list<int>));

append_t<float>();
static_assert(typeid(get_list_t<>) == typeid(type_list<int, float>));
```
<!-- .element: class="fragment" -->

##### Possible since C++17+ via friend injection (stateful meta-programming)
<!-- .element: class="fragment" -->

----

#### CppMeta - injection - https://www.codereckons.com/articles/65cbc0511318c3d21078737b

```cpp
consteval void gen_cases(auto& builder, auto cases) {
  for (auto e : constants(cases)) {
    append_case(builder, make_decl_ref_expr(e)); // case N:
    append_return(builder, name_of(e));          //   return "...";
  }
}
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
template<class E>
constexpr auto to_string(E value) {
  switch(value) {
    %gen_cases(^E); // code generation...
    default :
      return "";
  }
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

##### Possible in C++98+ but very limited (via nested switch / performance depends on the compiler ability to flatten it)
<!-- .element: class="fragment" -->

----

##### Case study - `enum_name`

```cpp
// simple enum
enum E { A, B };
```
<!-- .element: class="fragment" -->

```cpp
// flag enum
enum class E_flag {
  A = 0b001,
  B = 0b010,
  C = 0b100,
};
```
<!-- .element: class="fragment" -->

```cpp
// combined cases enum
enum class e_combined {
  zero = 0,
  big  = 879,
  _3   = 3,
  _4   = 4,
  _5   = 5,
  _6   = 6,
  _7   = 7,
};
```
<!-- .element: class="fragment" -->

##### [note] Code based on enum_name but ideas are generally applicable
<!-- .element: class="fragment" -->

----

#### C++26 - enum_name - https://godbolt.org/z/Eqffvn4dz

```cpp
template<class E>
  requires std::is_enum_v<E>
constexpr auto enum_name(E value) -> std::string {
  std::string result = ""; // unknown
  [:expand(std::meta::enumerators_of(^E)):] >> [&]<auto e> {
    if (value == [:e:]) {
      result = std::meta::name_of(e);
    }
  };
  return result;
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
static_assert("A" == enum_name(E::A));
static_assert("B" == enum_name(E::B));
static_assert(""  == enum_name(E(42));
```
<!-- .element: class="fragment" data-fragment-index="1" -->

##### As currently implemented in https://wg21.link/P2996
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### C++26 - enum_name - https://godbolt.org/z/Eqffvn4dz

```cpp
template<class E>
  requires std::is_enum_v<E>
constexpr auto enum_name(E value) -> std::string {
  template for (constexpr auto e : std::meta::enumerators_of(^E)) {
    if (value == [:e:]) {
      return std::string(std::meta::name_of(e)); // can early exit
    }
  }
  return ""; // unknown
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
static_assert("A" == enum_name(E::A));
static_assert("B" == enum_name(E::B));
static_assert(""  == enum_name(E(42));
```
<!-- .element: class="fragment" data-fragment-index="1" -->

##### Expansion statements - https://wg21.link/P1306
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### C++26 - enum_name - https://godbolt.org/z/s54hhP3Ys

```cpp
template auto enum_name(E) -> std::string; // x86-64 assembly
```
<!-- .element: class="fragment" -->

<img src="images/enum.png" style="width: 16%; background:none; border:none; box-shadow:none;" />
<!-- .element: class="fragment" -->

###### EDG (experimental reflection)
<!-- .element: class="fragment" -->

----

#### C++26 - enum_name - trade-offs?

- ##### compile-time / compilation-times
<!-- .element: class="fragment" -->

- ##### run-time
<!-- .element: class="fragment" -->

  - ##### performance
<!-- .element: class="fragment" -->

    - ##### if-else/jump-table/switch-case/hashing,...
<!-- .element: class="fragment" -->

  - ##### binary size
<!-- .element: class="fragment" -->

    - ##### return type / buffer sharing
<!-- .element: class="fragment" -->

  - ##### usability
<!-- .element: class="fragment" -->

    - ##### unknown value / flag enums (A|B)
<!-- .element: class="fragment" -->

----

#### v2::enum_name

---

- ##### Trying to address enum-name's trade-offs
<!-- .element: class="fragment" -->

- ##### Possible to implement in C++20 (https://github.com/boost-ext/reflect)
<!-- .element: class="fragment" -->

----

#### v2::enum_name

```cpp
template<
  string_view unknown = "",      // aka fixed_string
  auto policy = enum_name_policy // we will get back to that...
>
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
[[nodiscard]] constexpr auto enum_name(Enum auto e) noexcept {
  if constexpr (constexpr auto cases = std::meta::enumerators_of(^E);
    std::empty(cases)) {
    return unknown;
  } else {
    return policy.template operator()<cases, unknown>(e);
  }
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

###### Possible in C++20 (https://github.com/boost-ext/reflect)
<!-- .element: class="fragment" data-fragment-index="2" -->

----

##### `if-else` - https://godbolt.org/z/fbcT76ocT

```cpp
template<auto cases, auto unknown>
[[nodiscard]] constexpr auto if_else(Enum auto value) noexcept {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  static constexpr auto buffer = to<std::array>(cases); // "AB"

  template for (constexpr auto c : cases) { // P1306
    if (value == [:c:]) {
      return make<decltype(unknown)>(&buffer[offset<cases>(c)],
                                     size(c));
    }
  }

  return unknown;
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

##### `if-else` - https://godbolt.org/z/fbcT76ocT

```cpp
enum E { A, B };
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
enum_name(E):
        test    edi, edi
        je      .L4
        xor     eax, eax
        xor     edx, edx
        cmp     edi, 1
        je      .L7
.L3:
        xchg    rdx, rax
        ret
.L4:
        mov     eax, buffer   // A
.L2:
        mov     edx, 1        // size
        jmp     .L3
.L7:
        mov     eax, buffer+1 // B
        jmp     .L2
buffer:
        .ascii  "AB"          // enum names
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

##### `jump-table` - https://godbolt.org/z/q76ErE99P

```cpp
template<auto cases, auto unknown>
[[nodiscard]] constexpr auto jump_table(Enum auto e) noexcept {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  return [&]<auto... Is>(std::index_sequence<Is...>) {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
    static constexpr buffer = to<std::array>(cases); // "AB"
    // consider alignas(std::hardware_destructive_interference_size)
    static constexpr auto jump_table = std::array{ [&] {
      if constexpr (constexpr auto case = cases[I]) {
        return make<decltype(unknown)>(&buffer[offset<cases>(case)],
                                       size<cases>(case));
      } else { return unknown; } }()...
    };
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
    const auto value = std::to_underlying(e);
    if (value < min(cases) or value > max(cases)) [[unlikely]] {
      return unknown;
    }
    return jump_table[value-min(cases)];
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
  }(std::make_index_sequence<std::size(cases)>{});
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

##### `jump-table` - https://godbolt.org/z/q76ErE99P
```cpp
enum_name(E):
        cmpl    $1, %edi
        ja      .L3
        movl    %edi, %edi
        salq    $4, %rdi
        movq    jump_table(%rdi), %rax
        movq    jump_table+8(%rdi), %rdx
        ret
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
.L3:
        xorl    %eax, %eax
        xorl    %edx, %edx
        ret
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
jump_table:              // storage can be improved (later slides...)
        .quad   1        // size (std::string_view::size:std::size_t)
        .quad   buffer   // A
        .quad   1        // size
        .quad   buffer+1 // B
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
buffer:
        .ascii  "AB"     // enum names
```
<!-- .element: class="fragment" data-fragment-index="3" -->

----

##### `switch-case` - compiler heuristics for switch lowering strategies

---

##### https://github.com/gcc-mirror/gcc/blob/master/gcc/tree-switch-conversion.cc
<!-- .element: class="fragment" data-fragment-index="0" -->

----

##### `switch-case` - [gcc] switch lowering strategies (for clusters)

##### bitset (gcc)
<!-- .element: class="fragment" -->

```cpp
bool bit_test_cluster::is_beneficial (unsigned count, unsigned uniq) {
    // count: number of cases, uniq: number of distinct edges
    return ((uniq == 1 && count >= 3) ||
            (uniq == 2 && count >= 5) ||
            (uniq == 3 && count >= 6));
}
```
<!-- .element: class="fragment" -->

##### jump-table (gcc/clang)
<!-- .element: class="fragment" -->

```cpp
unsigned int case_values_threshold (void) {
  return (targetm.have_casesi () ? 4 : 5); // casesi: hardware support
}
bool jump_table_cluster::is_beneficial (unsigned start, unsigned end) {
    if (start == end) return false;
    return end - start + 1 >= case_values_threshold ();
}
```
<!-- .element: class="fragment" -->

##### decision tree comparisons (gcc/clang)
<!-- .element: class="fragment" -->
```cpp
otherwise (it takes __builtin_expect_with_probability into account)
```
<!-- .element: class="fragment" -->

----

##### `switch-case` - https://godbolt.org/z/vozn8csWr

```cpp
template<auto cases, auto unknown>
[[nodiscard]] constexpr auto switch_case(Enum auto e)  {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  static constexpr auto buffer = to<std::array>(cases); // "AB"

  auto switch_case = [&]<auto I = 0>(auto switch_case, auto value) {
    switch (value) {
      case cases[I]:
        return make<decltype(unknown)>(&buffer[offset<cases>(cases[I])],
                                       size(cases[I]));
      default:
        if constexpr (I < std::size(cases)) {
          return switch_case.template
            operator()<I+1>(switch_case, value);
        } else { return unknown; }
      }
    }
  };
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  return switch_case(switch_case, std::to_underlying(e));
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

##### `switch-case` - https://godbolt.org/z/vozn8csWr

```cpp
enum_name(E):
        test    edi, edi
        mov     edx, buffer+1 // B
        mov     eax, buffer   // A
        cmovne  rax, rdx      // conditional move
        mov     rdx, rax
        mov     eax, 1        // size
        ret
```

```cpp
buffer:
        .ascii  "AB"          // enum names

```

----

##### `switch-case` - https://godbolt.org/z/cYj4381GW

```cpp
template auto enum_name(e_combined) // x86-64 assembly
```
<!-- .element: class="fragment" -->

<img src="images/switch.png" style="width: 23%; background:none; border:none; box-shadow:none;" />
<!-- .element: class="fragment" -->

----

###### Minimal-Perfect-Hashing (MPH)

<img src="images/mph.png" style="width: 40%; background:none; border:none; box-shadow:none;" />
<!-- .element: class="fragment" -->

- ##### Minimal perfect hashing maps keys into range from 0 to N-1
<!-- .element: class="fragment" -->

  - ##### Brute-force* hash finding (multiply/shift/xor)
  <!-- .element: class="fragment" -->

  - ##### Hardware accelerated (ex. [X86-64/BMI2/PEXT](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=pext))
  <!-- .element: class="fragment" -->
    ```cpp
    word:   0010101011010111
    mask:   0011100100100010
    masked: __101__0__0___1_
    PEXT:   __________101001 (latency: 3, uops: 1)
    ```
    <!-- .element: class="fragment" -->

----

##### Minimal-Perfect-Hashing - https://github.com/boost-ext/mph

```cpp
template<auto cases, auto unknown> [[nodiscard]] [[gnu::target("bmi2")]]
constexpr auto mph(ScopedEnum auto e) noexcept {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  constexpr auto keys = [&]<auto... Is>(std::index_sequence<Is...>) {
    return std::array{std::pair{index(cases[Is]),
                                offset<cases>(cases[Is])}...};
  }(std::make_index_sequence<std::size(cases)>{});
```
<!-- .element: class="fragment" -->

```cpp
  // find unique mask which can represent all keys
  constexpr auto mask = find_mask<keys>();
```
<!-- .element: class="fragment" -->

```cpp
  const auto ext = pext(std::to_underlying(e), mask);
```
<!-- .element: class="fragment" -->


```cpp
  static constexpr auto index =       // index table
    make_index<keys, mask>();         // size=2^popcount(mask)
  static constexpr auto buffer =
    to<std::array, with_size>(cases); // "1A1B"
```
<!-- .element: class="fragment" -->

```cpp
  const auto value = index[ext];
  return make<decltype(unknown)>(&buffer[index+1], buffer[index]);
```
<!-- .element: class="fragment" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

##### Minimal-Perfect-Hashing - https://godbolt.org/z/6P3crWvEW

```cpp
enum_name(e_combined):
  mov eax, 519       // mask computed at compile-time (find_mask)
  pext edi, edi, rdx // wikipedia/X86_Bit_manipulation_instruction_set
  movzx edx, BYTE PTR index[rdi]
  movsx rdx, BYTE PTR buffer[rdx]
  ret
```
<!-- .element: class="fragment" -->

```cpp
index: // index table for offsets in the buffer
  .byte 0  .byte 0  .byte 0  .byte 5
  .byte 8  .byte 11 .byte 14 .byte 17
  .byte 0  .byte 0  .byte 0  .byte 0
  .byte 0  .byte 0  .byte 0  .byte 20
```
<!-- .element: class="fragment" -->

```cpp
buffer:
  .string "\4zero\2_32_4\2_5\2_6\2_7\3big" // [size][name]...
```
<!-- .element: class="fragment" -->

##### Same assembly for different enums  but index and buffer may grow ([llvm-mca](https://godbolt.org/z/G5oe9Ws3v) / [uops](https://uica.uops.info))
<!-- .element: class="fragment" -->

----

#### v2::enum_name - policy

```cpp
constexpr auto enum_name_policy =
  []<auto cases, auto unknown>(Enum auto e) noexcept {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  // Example heuristic but it's likely to
  // be different for specific use cases
  // Measure for your use case!
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  if constexpr (std::size(cases) <= 2) {
    return if_else<cases, unknown>(e);
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
  } else if constexpr (cases.max()-cases.min() <= 8) {
    return jump_table<cases, unknown>(e);
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
  } else if constexpr (requires { mph<cases, unknown>(e); }) {
    return mph<cases, unknown>(e);
```
<!-- .element: class="fragment" data-fragment-index="5" -->

```cpp
  } else {
    return switch_case<cases, unknown>(e);
  }
```
<!-- .element: class="fragment" data-fragment-index="6" -->

```cpp
};
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

#### Summary

* #### Static reflection enables a lot of optimizations/new use cases
<!-- .element: class="fragment" -->

* #### https://wg21.link/P2996 is the C++26's static reflection proposal
<!-- .element: class="fragment" -->

* #### Compile-time reflection has run-time parts
<!-- .element: class="fragment" -->

* #### There is no silver bullet if it comes to the performance (just trade-offs)
<!-- .element: class="fragment" -->
  - #### Policies are one way of dealing with these trade-offs for specific cases
  <!-- .element: class="fragment" -->

----

### Let's embrace compile-time reflection!

---

* #### C++26 Static reflection (https://wg21.link/P2996)
<!-- .element: class="fragment" -->

* #### C++20 (https://github.com/boost-ext/{mp,reflect,mph})
<!-- .element: class="fragment" -->

---

###### [kris@jusiak.net](mailto:kris@jusiak.net) | [@krisjusiak](https://twitter.com/krisjusiak) | [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)
          </script>
        </section>

      </div>
    </div>

    <script src="reveal.js/lib/js/head.min.js"></script>
    <script src="reveal.js/js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({

        // Display controls in the bottom right corner
        controls: false,

        // Display a presentation progress bar
        progress: false,

        // Display the page number of the current slide
        slideNumber: 'c/t',

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // Hides the address bar on mobile devices
        hideAddressBar: true,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style
        transition: 'none', // none/fade/slide/convex/concave/zoom

        // Transition speed
        transitionSpeed: 'default', // default/fast/slow

        // Transition style for full page slide backgrounds
        backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Parallax background image
        parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // Parallax background size
        parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

        // Number of pixels to move the parallax background per slide
        // - Calculated automatically unless specified
        // - Set to 0 to disable movement along an axis
        parallaxBackgroundHorizontal: null,
        parallaxBackgroundVertical: null,

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true },
          { src: 'extensions/plugin/line-numbers/line-numbers.js' }
        ]
      });

      <!--window.addEventListener("mousedown", handleClick, false);-->
      <!--window.addEventListener("contextmenu", function(e) { e.preventDefault(); }, false);-->

      function handleClick(e) {
        if (1 >= outerHeight - innerHeight) {
          document.querySelector( '.reveal' ).style.cursor = 'none';
        } else {
          document.querySelector( '.reveal' ).style.cursor = '';
        }

        e.preventDefault();
        if(e.button === 0) Reveal.next();
        if(e.button === 2) Reveal.prev();
      }
    </script>

  </body>
</html>
