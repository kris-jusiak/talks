<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>++namedtuple: Python-style Named Tuples in C++20</title>

    <link rel="stylesheet" href="reveal.js/css/reveal.css">
    <link rel="stylesheet" href="reveal.js/css/theme/league.css" id="theme">
    <link rel="stylesheet" href="extensions/plugin/line-numbers/line-numbers.css">
    <link rel="stylesheet" href="extensions/css/highlight-styles/zenburn.css">
    <link rel="stylesheet" href="extensions/css/custom.css">

    <style>
      .reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5 { text-transform: none; }
    </style>

    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );

      function set_address(self, remote, local) {
        if (window.location.search.match("local")) {
          self.href = local;
        } else {
          self.href = remote;
        }
      }
    </script>

    <meta name="description" content="++namedtuple: Python-style Named Tuples in C++20">
    <meta name="author" content="Kris Jusiak">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
          <section data-markdown="">
          <script type="text/template">

<a href="https://cppcon.org/"><img src="images/cppcon2021.png" style="width: 35%; background:none; border:none; box-shadow:none;" /></a>

---

## ++namedtuple: Python-style Named Tuples in C++20

---

###### [kris@jusiak.net](mailto:kris@jusiak.net) | [@krisjusiak](https://twitter.com/krisjusiak) | [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)

          </script>
          </section>
          <section data-markdown=""
                   data-separator="^====+$"
                   data-separator-vertical="^----+$">
          <script type="text/template">
### Agenda

* #### Motivation
<!-- .element: class="fragment" data-fragment-index="1" -->
* #### Implementation
<!-- .element: class="fragment" data-fragment-index="2" -->
* #### Showcase
<!-- .element: class="fragment" data-fragment-index="2" -->
* #### Summary
<!-- .element: class="fragment" data-fragment-index="5" -->

---

##### <p align="left" style="background-color:darkblue">&nbsp;&nbsp;&nbsp;&nbsp;`darkblue background - something to remember ‚úì`</p>
<!-- .element: class="fragment" data-fragment-index="6" -->

##### <p align="left" style="background-color:green">&nbsp;&nbsp;&nbsp;&nbsp;`green background - achivement unlocked üëç`</p>
<!-- .element: class="fragment" data-fragment-index="7" -->

###### Powered by [Compiler Explorer](https://godbolt.org)
<!-- .element: class="fragment" data-fragment-index="8" -->

==============================================================================

### Motivation

> Python‚Äôs namedtuple was created to improve code readability by providing a way to access values using descriptive field names instead of integer indices, which most of the time don‚Äôt provide any context on what the values are. This feature also makes the code cleaner and more maintainable.

----

#### std::tuple - Problems

```cpp
const auto x = 4;
const auto y = 2;

const auto t = std::tuple{x, y};
```
<!-- .element: class="fragment" -->

```cpp
const auto x = std::get<int>(t); // compilation error!
```
<!-- .element: class="fragment" -->

```cpp
const auto y = std::get<0>(t);   // wrong value!
const auto x = std::get<1>(t);   // wrong value!
```
<!-- .element: class="fragment" -->

```cpp
const auto [y, x] = t;           // wrong values!
```
<!-- .element: class="fragment" -->

----

#### std::tuple - Problems

```cpp
std::get<2>(t);                  // missing SFINAE friendiness!
```
<!-- .element: class="fragment" -->

---

```cpp
constexpr auto t1 = std::tuple(42,  2, 'z');
constexpr auto t2 = std::tuple(42, 'z', 2);
static_assert(8 == sizeof(t1));
static_assert(12 == sizeof(t2)); // oops, not packed!
```
<!-- .element: class="fragment" -->

----

#### std::tuple - Dream

```cpp
constexpr auto t = tuple(x = 42, y = 2);
static_assert(4 == t.x);
static_assert(2 == t.y);
```
<!-- .element: class="fragment" -->

---

```cpp
std::cout << t;
```
<!-- .element: class="fragment" -->

```sh
{x:4,y:2}
```
<!-- .element: class="fragment" -->

----

#### std::tuple - Dream

```cpp
to_json(t);
```
<!-- .element: class="fragment" -->

```json
{
  'x' : 4,
  'y' : 2
}
```
<!-- .element: class="fragment" -->

```cpp
std::vector<decltype(t)> ts{t};

db.query("SELECT x, y FROM points", ts);
```
<!-- .element: class="fragment" -->

```sh
id,x,y
 0,4,2
```
<!-- .element: class="fragment" -->

----

#### std::tuple - Dream

```cpp
static_assert(requires { t.x; });
static_assert(requires { t.y; });
static_assert(not requires { t.z; });
```
<!-- .element: class="fragment" -->

```cpp
constexpr auto t1 = tuple(x = 42, y = 2,   z = 'z');
constexpr auto t2 = tuple(x = 42, z = 'z', y = 2);
static_assert(8 == sizeof(t1));
static_assert(8 == sizeof(t2));
```
<!-- .element: class="fragment" -->

----

#### std::tuple - Dream

```cpp
constexpr auto t = tuple(x, y);
t.x = 4;
t.y = 2;
static_assert(4 == t.x);
static_assert(2 == t.y);
```
<!-- .element: class="fragment" -->

---

```cpp
constexpr auto t2 = tuple(t, z = 10);
static_assert(4 == t.x);
static_assert(2 == t.y);
static_assert(10 == t.z);
```
<!-- .element: class="fragment" -->

==============================================================================

### The Goal

---

> To make `++namedtuple` dream come true!
<!-- .element: class="fragment" -->

----

#### The Goal vs the Reality

```cpp
constexpr auto t = namedtuple{"x"_t = 4, "y"_t = 2};
```
<!-- .element: class="fragment" -->

```cpp
static_assert(4 == t["x"_t]);
static_assert(2 == t["y"_t]);
```
<!-- .element: class="fragment" -->

----

#### The Goal vs the Reality

```cpp
std::cout << t;
```

<!-- .element: class="fragment" -->

```sh
{x:4,y:2}
```
<!-- .element: class="fragment" -->

---

```cpp
constexpr auto t = namedtuple<"Point">{"x"_t = 4, "y"_t = 2};
std::cout << t;
```

<!-- .element: class="fragment" -->

```sh
Point{x:4,y:2}
```
<!-- .element: class="fragment" -->

----

#### The Goal vs the Reality

```cpp
to_json(t);
```
<!-- .element: class="fragment" -->

```json
{
  'Point' : {
    'x' : 4,
    'y' : 2
  }
}
```
<!-- .element: class="fragment" -->

----

#### The Goal vs the Reality

```cpp
std::get<0>(t);  // still works but issues remain!
std::get<1>(t);  // still works but issues remain!
```
<!-- .element: class="fragment" -->

```cpp
auto [x, y] = t; // still works but issues remain!
```
<!-- .element: class="fragment" -->

----

#### The Goal vs the Reality

```cpp
constexpr auto t = namedtuple("x"_t, "y"_t);
t["x"_t] = 4;
t["y"_t] = 2;
static_assert(4 == t["x"_t]);
static_assert(2 == t["y"_t]);
```
<!-- .element: class="fragment" -->

---

```cpp
constexpr auto t2 = namedtuple(t, "z"_t = 10);
static_assert(4 == t["x"_t]);
static_assert(2 == t["y"_t);
static_assert(10 == t["z"_t]);
```
<!-- .element: class="fragment" -->

----

#### The Goal vs the Reality

```cpp
static_assert(not [](auto tuple) {
   return requires { t["z"_t];}(tuple) // SFINAE friendly!
);
```
<!-- .element: class="fragment" -->

---

```cpp
constexpr auto t1 = namedtuple("x"_t = 42, "y"_t = 2,   "z"_t = 'z');
constexpr auto t2 = namedtuple("x"_t = 42, "z"_t = 'z', "y"_t = 2);
static_assert(8 == sizeof(t1));
static_assert(8 == sizeof(t2));
```
<!-- .element: class="fragment" -->

==============================================================================

### Implementation*

> \* Simplified (~100 LOC) / C++20
<!-- .element: class="fragment" -->

----

```cpp
static_assert("name"sv == ("name"_t = 42).name);
static_assert(42       == ("name"_t = 42).value);
```
<!-- .element: class="fragment" -->

```cpp
template <fixed_string Name>
constexpr auto operator""_t() { return arg<Name, any>{}; }
```

----

```cpp
static_assert(""sv     == fixed_string(""));
static_assert("name"sv == fixed_string("name"));
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
template <auto Size>
struct fixed_string {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  char data[Size + 1]{};
  static constexpr auto size = Size;

  constexpr explicit(false) fixed_string(char const* str) {
    std::copy_n(str, Size + 1, data);
  }
  constexpr explicit(false) operator std::string_view() const {
    return {data, Size};
  }
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
};
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
template <auto Size>
fixed_string(char const (&)[Size]) -> fixed_string<Size - 1>;
```
<!-- .element: class="fragment" data-fragment-index="1" -->

C++ 20 feature

----

```cpp
template <fixed_string Name, class TValue>
struct arg {
  static constexpr auto name = Name;
  TValue value{};

  template <class T>
  constexpr auto operator=(const T& t) { return arg<Name, T>{.value = t}; }
};
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----


```cpp
constexpr auto nt = namedtuple("x"_t = 42, "y"_t = 100);
static_assert(42  == nt["x"_t]);
static_assert(100 == nt["y"_t]);
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
template<class... Ts>
struct namedtuple : std::tuple<Ts...> {
  using std::tuple<Ts...>:tuple;

  constexpr auto& operator[](const auto& t) {

  }
};
```

----

```cpp
static_assert(std::is_same_v<void, map_lookup<inherit<arg<"price", double>, arg<"size", int>>, "unknown", void>>);
static_assert(std::is_same_v<arg<"price", double>, map_lookup<inherit<arg<"price", double>, arg<"size", int>>, "price", void>>);
static_assert(std::is_same_v<arg<"size", int>, map_lookup<inherit<arg<"price", double>, arg<"size", int>>, "size", void>>);
```

```cpp
template <class T, fixed_string TKey, class TDefault, template <fixed_string, class> class TArg>
using map_lookup = decltype(detail::map_lookup<TDefault, TKey, TArg>(static_cast<T*>(nullptr)));
```

```cpp
namespace detail {
template <class TDefault, fixed_string, template <fixed_string, class> class>
auto map_lookup(...) -> TDefault;
template <class, fixed_string TKey, template <fixed_string, class> class TArg,
          class TValue>
auto map_lookup(TArg<TKey, TValue>*) -> TArg<TKey, TValue>;

template <class TDefault, class, template <class, class> class>
auto map_lookup(...) -> TDefault;
template <class, class TKey, template <class, class> class TArg, class TValue>
auto map_lookup(TArg<TKey, TValue>*) -> TArg<TKey, TValue>;
}  // namespace detail
```

----

```cpp
template <fixed_string Name, class... Ts>
struct namedtuple : Ts... {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  constexpr explicit(true) namedtuple(Ts... ts) : Ts{ts}... {}
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  template <class T, class TArg = map_lookup<namedtuple, T::name, void, arg>>
    requires(not std::is_void_v<TArg>) {
  constexpr const auto& operator[](const T) const;
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
  template <class T, class TArg = map_lookup<namedtuple, T::name, void, arg>>
     requires(not std::is_void_v<TArg>) {
  constexpr auto& operator[](const T);
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
  auto& assign(auto&&... ts);
```
<!-- .element: class="fragment" data-fragment-index="5" -->

```cpp
  template <std::size_t N> auto& get();
```
<!-- .element: class="fragment" data-fragment-index="6" -->

```cpp
  friend std::ostream& operator<<(std::ostream& os, const namedtuple& nt);
```
<!-- .element: class="fragment" data-fragment-index="7" -->

```cpp
};
template <class... Ts>
namedtuple(Ts...) -> namedtuple<"", Ts...>;
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

  auto& assign(auto&&... ts) {
    if constexpr ((requires {
                    ts.name;
                    ts.value;
                  } and
                   ...)) {
      ((static_cast<decltype(ts)&>(*this) = ts), ...);
    } else {
      ((static_cast<Ts&>(*this).value = ts), ...);
    }
    return *this;
  }

  template <std::size_t N>
  auto& get() {
    auto id_type = []<auto... Ns>(std::index_sequence<Ns...>) {
      return inherit<
          std::pair<std::integral_constant<std::size_t, Ns>, Ts>...>{};
    }
    (std::make_index_sequence<sizeof...(Ts)>{});
    return static_cast<
               typename decltype(detail::map_lookup<
                                 void, std::integral_constant<std::size_t, N>,
                                 std::pair>(&id_type))::second_type&>(*this)
        .value;
  }

  friend std::ostream& operator<<(std::ostream& os, const named_tuple& nt) {
    os << std::string_view{Name} << '{';
    [&]<auto... Ns>(std::index_sequence<Ns...>) {
      ((os << (Ns ? "," : "") << std::string_view{Ts::name} << ':'
           << static_cast<const map_lookup<named_tuple, Ts::name, void, arg>&>(
                  nt)
                  .value),
       ...);
    }
    (std::make_index_sequence<sizeof...(Ts)>{});
    os << '}';
    return os;
  }

----

```cpp
auto [x, y] = namedtuple("x"_t = 4, "y"_t = 2);
static_assert(4 == x);
static_assert(2 == y);
```

---

```cpp
namespace std {
template <fixed_string Name, class... Ts>
struct tuple_size<namedtuple<Name, Ts...>>
    : std::integral_constant<std::size_t, sizeof...(Ts)> {};
```

---

```cpp
template <std::size_t N, fixed_string Name, class... Ts>
struct tuple_element<N, namedtuple<Name, Ts...>> {
  using type =
      decltype(std::declval<namedtuple<Name, Ts...>>().template get<N>());
};
}  // namespace std
```

----

#### Full implementation at:

* #### https://godbolt.org/z/753d8M6Wx
<!-- .element: class="fragment" -->

==============================================================================

### Showcase

```cpp
constexpr auto employee = namedtuple<"Employee">("name"_t, "age"_t, "title"_t);
```
<!-- .element: class="fragment" -->

```cpp
std::vector<decltype(employee)> employees{};
employees.emplace_back("John", 24, "Software Engineer");
employees.emplace_back("Mike", 36, "Senior Software Engineer");
```
<!-- .element: class="fragment" -->

```cpp
to_json(employees);
```
<!-- .element: class="fragment" -->

```json
{
  [
    "Employee" : {
      "name"  : "John",
      "age"   : 24,
      "title" : "Software Engineer"
    },
    "Employee" : {
      "name"  : "Mike",
      "age"   : 36,
      "title" : "Senior Software Engineer"
    }
  ]
}
```
<!-- .element: class="fragment" -->

```cpp
constexpr auto employee = namedtuple<"Employee">(employee, "department"_t);
employee 
```
<!-- .element: class="fragment" -->


==============================================================================

<img src="images/pythonic_cpp.png" style="width: 35%; background:none; border:none; box-shadow:none;" />

---

Let's `name(d)` all `tuple(s)`!

---

#### https://www.quantlab.com/careers
<!-- .slide: data-background-color="white" style="color:black" -->

          </script>
        </section>

      </div>
    </div>

    <script src="reveal.js/lib/js/head.min.js"></script>
    <script src="reveal.js/js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({

        // Display controls in the bottom right corner
        controls: false,

        // Display a presentation progress bar
        progress: false,

        // Display the page number of the current slide
        slideNumber: 'c/t',

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // Hides the address bar on mobile devices
        hideAddressBar: true,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style
        transition: 'none', // none/fade/slide/convex/concave/zoom

        // Transition speed
        transitionSpeed: 'default', // default/fast/slow

        // Transition style for full page slide backgrounds
        backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Parallax background image
        parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // Parallax background size
        parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

        // Number of pixels to move the parallax background per slide
        // - Calculated automatically unless specified
        // - Set to 0 to disable movement along an axis
        parallaxBackgroundHorizontal: null,
        parallaxBackgroundVertical: null,

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true },
          { src: 'extensions/plugin/line-numbers/line-numbers.js' }
        ]
      });

      <!--window.addEventListener("mousedown", handleClick, false);-->
      <!--window.addEventListener("contextmenu", function(e) { e.preventDefault(); }, false);-->

      function handleClick(e) {
        if (1 >= outerHeight - innerHeight) {
          document.querySelector( '.reveal' ).style.cursor = 'none';
        } else {
          document.querySelector( '.reveal' ).style.cursor = '';
        }

        e.preventDefault();
        if(e.button === 0) Reveal.next();
        if(e.button === 2) Reveal.prev();
      }
    </script>

  </body>
</html>
