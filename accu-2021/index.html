<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Future of Testing with C++20</title>

    <link rel="stylesheet" href="reveal.js/css/reveal.css">
    <link rel="stylesheet" href="reveal.js/css/theme/league.css" id="theme">
    <link rel="stylesheet" href="extensions/plugin/line-numbers/line-numbers.css">
    <link rel="stylesheet" href="extensions/css/highlight-styles/zenburn.css">
    <link rel="stylesheet" href="extensions/css/custom.css">

    <style>
      .reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5 { text-transform: none; }
    </style>

    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );

      function set_address(self, remote, local) {
        if (window.location.search.match("local")) {
          self.href = local;
        } else {
          self.href = remote;
        }
      }
    </script>

    <meta name="description" content="Future of Testing with C++20">
    <meta name="author" content="Kris Jusiak">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
          <section data-markdown="" data-background-image="images/accu.jpg">
          <script type="text/template">
<br />&nbsp;
<br />&nbsp;
<br />&nbsp;
<br />&nbsp;
<br />&nbsp;
<br />&nbsp;
<br />&nbsp;
<br />&nbsp;
<br />&nbsp;
<p style="background-color:black; font-size: 22px;">
https://boost-ext.github.io/ut/accu-2021
<br />
kris@quantlab.com | https://www.quantlab.com/careers
</p>
          </script>
          </section>
          <section data-markdown=""
                   data-separator="^====+$"
                   data-separator-vertical="^----+$">
          <script type="text/template">
### Agenda

* #### Motivation
<!-- .element: class="fragment" data-fragment-index="1" -->
* #### Implementation (Simplified / C++20)
<!-- .element: class="fragment" data-fragment-index="2" -->
* #### UT - Unit Testing Framework
<!-- .element: class="fragment" data-fragment-index="3" -->
* #### Benchmarks
<!-- .element: class="fragment" data-fragment-index="4" -->
* #### Summary
<!-- .element: class="fragment" data-fragment-index="5" -->

---

##### <p align="left" style="background-color:darkblue">&nbsp;&nbsp;&nbsp;&nbsp;`darkblue background - something to remember ‚úì`</p>
<!-- .element: class="fragment" data-fragment-index="6" -->

##### <p align="left" style="background-color:green">&nbsp;&nbsp;&nbsp;&nbsp;`green background - achivement unlocked üëç`</p>
<!-- .element: class="fragment" data-fragment-index="7" -->

###### Powered by [Compiler Explorer](https://godbolt.org)
<!-- .element: class="fragment" data-fragment-index="8" -->

==============================================================================

### Motivation

```cpp
constexpr auto sum(auto... args) { return (args + ...); }
```
<!-- .element: class="fragment" -->

```cpp
int main() {
  // should sum numbers
  {
    assert(3 == sum(1, 2));
  }
}
```
<!-- .element: class="fragment" -->

----

### Motivation - Problems

* #### No ability to list/run specific tests
<!-- .element: class="fragment" -->
* #### No useful information when the test failed
<!-- .element: class="fragment" -->
* #### Hard to scale/integrate/debug
<!-- .element: class="fragment" -->
* #### Easy to make mistakes (implicit conversions, ...)
<!-- .element: class="fragment" -->
* #### Hard to follow good practises such as TDD/BDD
<!-- .element: class="fragment" -->
* #### ...
<!-- .element: class="fragment" -->

----

### Existing Solutions

* #### [GoogleTest](https://github.com/google/googletest)
<!-- .element: class="fragment" -->
* #### [Boost.Test](https://github.com/boostorg/test)
<!-- .element: class="fragment" -->
* #### [Catch2](https://github.com/catchorg/Catch2)
<!-- .element: class="fragment" -->
* #### [DocTest](https://github.com/onqtam/doctest)
<!-- .element: class="fragment" -->
* ...
<!-- .element: class="fragment" -->

----

### Existing Solutions - Problems

* #### Macro based*
<!-- .element: class="fragment" data-fragment-index="1" -->

* #### Boilerplate*
<!-- .element: class="fragment" data-fragment-index="2" -->

* #### Slow to compile*
<!-- .element: class="fragment" data-fragment-index="3" -->

* #### Hard to integrate*
<!-- .element: class="fragment" data-fragment-index="4" -->

* ...
<!-- .element: class="fragment" data-fragment-index="5" -->

> \* Generalized
<!-- .element: class="fragment" data-fragment-index="0" -->

----

### Future (C++20)?

* #### No macros
<!-- .element: class="fragment" -->
* #### Minimal boilerpalte
<!-- .element: class="fragment" -->
* #### Minimal learning curve
<!-- .element: class="fragment" -->
* #### Easy integration
<!-- .element: class="fragment" -->
* #### Flexible/Scalable
<!-- .element: class="fragment" -->
* #### Fast to compile/execute
<!-- .element: class="fragment" -->

----

### The Goal

```cpp
constexpr auto sum(auto... args) { return (0 + ... + args); }
```
<!-- .element: class="fragment" -->

```cpp
01 import ut;               // C++20 module
02
03 int main() {
04   "sum"_test = [] {      // Running... sum
05      sum(1, 2) == 42_i;  // sum.cpp:5:FAILED [ 3 == 42 ]
06   };                     // tests:   1 | 1 failed
07 }                        // asserts: 1 | 0 passed | 1 failed
```
<!-- .element: class="fragment" -->

```cpp
01 import ut;
02
03 suite sums = [] {
04  "sum with no args"_test       = [] { expect(sum() == 0_i); };
05  "sum with single arg"_test    = [] { expect(sum(42) == 42_i); };
06  "sum with multiple args"_test = [] { expect(sum(1, 2) == 3_i); };
07 };
08
09 int main() {              // tests:   3 | 0 failed
10 }                         // asserts: 3 | 3 passed | 0 failed
```
<!-- .element: class="fragment" -->

==============================================================================

### Implementation*

> \* Simplified (~200 LOC) / C++20

----

#### ut.module

```cpp
import ut;
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

##### ut.hpp
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
export module ut; // module interface unit
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
import std;
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
export namespace ut::inline v1 {
  // ...
}
```
<!-- .element: class="fragment" data-fragment-index="4" -->

----

#### ut.module

---

##### main.cpp
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
01 import ut;
02
03 int main() {
04   // ...
05 }
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```sh
$CXX $CXXFLAGS -emit-module-interface -c ut.hpp -o ut.pcm
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```sh
$CXX $CXXFLAGS main.cpp ut.pcm -o main
```
<!-- .element: class="fragment" data-fragment-index="3" -->

<pre><code>./main</code> -> <font color="lime">‚úîÔ∏è</font></pre>
<!-- .element: class="fragment" data-fragment-index="4" -->

----

#### Modules / C++20 / [C++draft/module](http://eel.is/c++draft/module)

<img src="images/modules.png" style="width: 100%; background:none; border:none; box-shadow:none;" />

* #### "Similar" to Precompiled Headers (`PCH`)
<!-- .element: class="fragment" data-fragment-index="1" -->

* #### Allow to hide implementation details (detail namespace)
<!-- .element: class="fragment" data-fragment-index="2" -->

* #### Faster compilation times (across translation units)
<!-- .element: class="fragment" data-fragment-index="3" -->

<!-- .slide: data-background="darkblue" -->

----

#### ut::test

```cpp
01 import ut;              // ‚úîÔ∏è
02
03 int main() {
04   "sum"_test = [] {     //  ut::test / ""_test
```
<!-- .element: class="fragment" -->

----

#### ut::test - concept

```cpp
template <class T> concept printable =
  requires(std::ostream &os, T t) {
    os << t;
  };
```
<!-- .element: class="fragment" data-fragment-index="4" -->

---

```cpp
template <class T, auto expr = []{}> concept test =
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  requires(T test) {
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
    { test.name } -> printable;            // for "Running... test"
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
    { test = expr } -> std::same_as<void>; // for test = []{};
```
<!-- .element: class="fragment" data-fragment-index="5" -->

```cpp
  };
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### Concepts / C++20 / [C++draft/concepts](http://eel.is/c++draft/concepts)

---

* #### Type constraints (act like documentation for interfaces)
<!-- .element: class="fragment" data-fragment-index="1" -->

* #### Better error messages (Point Of Instantiation - POI)
<!-- .element: class="fragment" data-fragment-index="2" -->

* #### Faster compilation times (In comparison to Substitution Failure is Not an Error - SFINAE)
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
template<class T>
concept Auto = true; // the least constraint concept (same as auto)
```
<!-- .element: class="fragment" data-fragment-index="4" -->

---

###### Equivalent syntax
<!-- .element: class="fragment" data-fragment-index="5" -->

```cpp
                                   auto foo(auto arg);
template<class T> requires Auto<T> auto foo(T arg);
template<class T>                  auto foo(T arg) requires Auto<T>;
template<Auto T>                   auto foo(T arg);
                                   auto foo(Auto auto arg);
```
<!-- .element: class="fragment" data-fragment-index="5" -->

<!-- .slide: data-background="darkblue" -->

----

#### ut::test

```cpp
struct test {
  std::string_view name{}; // test case name
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  auto operator=(std::invocable auto test) -> void {
    std::clog << "Running... " << name << '\n';
    test();
  }
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
};
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
[[nodiscard]] constexpr concepts::test auto operator""_test(
  const char* name, std::size_t size) {
  return test{.name = {name, size}};
}
```
<!-- .element: class="fragment" data-fragment-index="3" -->

----

#### ut::test

```cpp
01 import ut;              // ‚úîÔ∏è
02
03 int main() {
04   "sum"_test = [] {     // ‚úîÔ∏è
05   };
06 }
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

<pre><code>Running... sum</code> -> <font color="lime">‚úîÔ∏è</font></pre>
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### Assertion

```cpp
01 import ut;              // ‚úîÔ∏è
02
03 int main() {
04   "sum"_test = [] {     // ‚úîÔ∏è
05      sum(1, 2) == 42_i; // ut::operator==, ut::""_i
06   };
07 }
```

----

#### Operator overloading / [C++draft/over.match.oper](http://eel.is/c++draft/over.match.oper)

<img src="images/over.match.oper.png" style="width: 100%; background:none; border:none; box-shadow:none;" />

<!-- .slide: data-background="darkblue" -->

----

#### Operator overloading - https://godbolt.org/z/G6Pzb3

```cpp
constexpr auto operator==(int, int) -> bool { return {}; }
```
<!-- .element: class="fragment" -->

<pre> -> <font color="salmon">error: overloaded 'operator==' must have at least
      one parameter of class or enumeration type
</font></pre>
<!-- .element: class="fragment" -->

---

<pre><code>template< auto N > constexpr auto operator==(
  std::integral_constant< int, N >, int) -> bool {
  return {};
}</code> -> <font color="lime">‚úîÔ∏è</font></pre>
<!-- .element: class="fragment" -->

<!-- .slide: data-background="darkblue" -->

----

#### ut::operator==

```cpp
template <class TOp> concept op =
  requires printable<TOp> and (
    requires(TOp op) { // eq, ...
      op.lhs; // left-hand side operator
      op.rhs; // right-hand side operator
      requires std::convertible_to<TOp, bool>; // expect
    } or
    requires(TOp op) { // integral_constant, 42_i
      typename TOp::value_type;
      op.value;
    }
  );
```
<!-- .element: class="fragment" data-fragment-index="2" -->

---

```cpp
template <class TLhs, class TRhs>
  requires concepts::op<TLhs> or concepts::op<TRhs>
constexpr concepts::op auto operator==(TLhs lhs, TRhs rhs) {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  return eq{lhs, rhs};
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### ut::eq

```cpp
template <class TLhs, class TRhs>
struct eq final {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  TLhs lhs{}; // left-hand side operator
  TRhs rhs{}; // right-hand side operator
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  ~eq() noexcept {
    if (not *this) { error(*this); }
  }
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
  [[nodiscard]] constexpr explicit(false) operator bool() const {
    return value(lhs) == value(rhs);
  }
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
  friend auto& operator<<(auto& os, const eq& op) {
    return (os << value(op.lhs) << " == " << value(op.rhs));
  }
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
};
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
template <class TLhs, class TRhs> eq(TLhs, TRhs) -> eq<TLhs, TRhs>;
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### ut::detail

```cpp
auto error(const auto& expr) -> void {
  std::cerr << "FAILED: " << expr << '\n';
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
constexpr auto value(auto op) { // underlying value
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  if constexpr (requires { op.value; }) {
    return op.value;
  } else {
    return op;
  }
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### Design By Introspection - https://d.godbolt.org/z/n8e4de

```cpp
constexpr auto foo(auto v) {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  if constexpr (requires{ v.foo; }) {
    return v.foo;
  } else {
    return 0;
  }
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
constexpr struct { int foo{42}; } f;
static_assert(42 == foo(f));
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
constexpr struct { int bar{42}; } b;
static_assert(0 == foo(b));
```
<!-- .element: class="fragment" data-fragment-index="5" -->

---

##### Andrei Alexandrescu - https://www.youtube.com/watch?v=HdzwvY8Mo-w
<!-- .element: class="fragment" data-fragment-index="6" -->

<!-- .slide: data-background="darkblue" -->

----

#### Assertion

```cpp
01 import ut;              // ‚úîÔ∏è
02
03 int main() {
04   "sum"_test = [] {     // ‚úîÔ∏è
05      sum(1, 2) == 42_i; // ut::operator== ‚úîÔ∏è, ut::""_i
06   };
07 }
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### User Defined Literals (`UDL`) - [C++draft/over.literal](http://eel.is/c++draft/over.literal)

<img src="images/over.literal.png" style="width: 100%; background:none; border:none; box-shadow:none;" />

---

```cpp
constexpr auto operator""_i(int) -> int;
```
<!-- .element: class="fragment" -->

<pre> -> <font color="salmon">error: invalid literal operator parameter type 'int',
      did you mean 'unsigned long long'?</font></pre>
<!-- .element: class="fragment" -->

<!-- .slide: data-background="darkblue" -->

----

#### ut::""_i - User Defined Literals (`UDL`) - https://godbolt.org/z/cZsSK3

```cpp
template <char... Cs>
[[nodiscard]] constexpr auto operator""_i() { // int
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  return []<auto... Ns>(std::index_sequence<Ns...>) {
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
    return std::integral_constant<int,
      ((std::pow(10, sizeof...(Ns) - Ns - 1)) * (Cs - '0')) + ...)
    >{};
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
  }(std::make_index_sequence<sizeof...(Cs)>{});
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
static_assert(0_i  == 0);
static_assert(42_i == 42);
```
<!-- .element: class="fragment" -->

----

#### Immediately-Invoked Function Expression (`IIFE`) - https://godbolt.org/z/aM58T1

```cpp
template<auto N>
constexpr auto unfold = [](auto expr) {
  [expr]<auto ...Is>(std::index_sequence<Is...>) {
    ((expr(), void(Is)), ...);
  }(std::make_index_sequence<N>{});
};
```
<!-- .element: class="fragment" -->

```cpp
int main() {
  unfold<2>([]{ std::puts("ACCU-2021!"); });
}
```
<!-- .element: class="fragment" -->

---

```cpp
.LC0: .string "ACCU-2021!"
main:
  sub     rsp, 8
  mov     edi, OFFSET FLAT:.LC0
  call    puts
  mov     edi, OFFSET FLAT:.LC0
  call    puts
  xor     eax, eax
  add     rsp, 8
  ret
```
<!-- .element: class="fragment" -->

<!-- .slide: data-background="darkblue" -->

----

#### Assertion

```cpp
01 import ut;              // ‚úîÔ∏è
02
03 int main() {
04   "sum"_test = [] {     // ‚úîÔ∏è
05      sum(1, 2) == 42_i; // ut::operator== ‚úîÔ∏è, ut::""_i ‚úîÔ∏è
06   };
07 }
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

<pre><code>Running... sum
FAILED: [3 == 42]</code> -> <font color="gray">It's missing FILE:LINE!</font></pre>
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### Source Location / C++20 / [C++draft/support.srcloc#source.location.syn](http://eel.is/c++draft/support.srcloc#source.location.syn)

<img src="images/source_location.png" style="width: 50%; background:none; border:none; box-shadow:none;" />

##### Macro-free replacement for `__FILE__`, `__LINE__`, `__function__`
<!-- .element: class="fragment" data-fragment-index="1" -->

<!-- .slide: data-background="darkblue" -->

----

#### Source Location / C++20 - https://godbolt.org/z/G6Pzb3

<pre><code>constexpr auto operator==(
  auto, auto, const std::source_location& location =
                    std::source_location::current()
) -> bool {
  return {};
}</code> -> <font color="salmon">error: parameter of overloaded 'operator=='
      cannot have a default argument
</font></pre>
<!-- .element: class="fragment" -->

----

#### Source Location / C++20

```cpp
auto error(const auto& expr, const auto& location) -> void {
  std::cerr << location.file_name() << ':' << location.line()
            << ":FAILED: " << expr << '\n';
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
template<class TLhs, class TRhs>
struct eq final {
  constexpr eq(TLhs lhs, TRhs rhs,
    std::source_location& location = // FILE:LINE -> ut.hpp:128
    std::source_location::current());
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  ~eq() noexcept {
    if (not *this) {
      error(*this, location_);
    }
  }
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
  TLhs lhs_{};
  TRhs rhs_{};
  std::source_location location_{};
};
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### Assertion

```cpp
01 import ut;              // ‚úîÔ∏è
02
03 int main() {
04   "sum"_test = [] {     // ‚úîÔ∏è
05      sum(1, 2) == 42_i; // ut::operator== ‚úîÔ∏è, ut::""_i ‚úîÔ∏è
06   };
07 }
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

<pre><code>Running... sum
ut.hpp:128:FAILED: [3 == 42]</code> -> <font color="gray">Wrong FILE:LINE!</font></pre>
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### ut::value_location

```cpp
template <class TValue> struct value_location {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  constexpr explicit(false)
    value_location(TValue value,
                   const std::source_location &location =
                         std::source_location::current())
    : value{value}, location{location} {}
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  TValue value{};
  std::source_location location{};
};
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### ut::value_location

```cpp
template <op T>
constexpr auto operator==(
  value_location<typename T::value_type> lhs, T rhs) {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  struct eq : detail::eq<decltype(lhs), decltype(rhs)> {
    ~eq() noexcept {
      if (not *this) {
        error(*this, lhs.location);
      }
    }
  };

  return eq{lhs, rhs};
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### Assertion

```cpp
01 import ut;              // ‚úîÔ∏è
02
03 int main() {
04   "sum"_test = [] {     // ‚úîÔ∏è
05      sum(1, 2) == 42_i; // ut::operator== ‚úîÔ∏è, ut::""_i ‚úîÔ∏è
06   };
07 }
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

<pre><code>Running... sum
test.cpp:05:FAILED: [3 == 42]</code> -> <font color="lime">‚úîÔ∏è</font></pre>
<!-- .element: class="fragment" data-fragment-index="2" -->

----

### Achievement Unlocked (First goal)

### üëç

<!-- .slide: data-background="green" -->

----

#### ut::suite / ut::expect

```cpp
01 import ut;// ‚úîÔ∏è
02
03 suite sums = [] { // ut::suite
04  "sum with no args"_test       = [] { expect(sum() == 0_i); };
05  "sum with single arg"_test    = [] { expect(sum(42) == 42_i); };
06  "sum with multiple args"_test = [] { expect(sum(1, 2) == 3_i); };
07 };
08
09 int main() {
10 }
```
<!-- .element: class="fragment" -->

----

#### ut::expect

```cpp
01 import ut; // ‚úîÔ∏è
02
03 int main() {
04   expect(sum(1, 2) == 21_i) << "?"; // ut::expect
05 }
```

----

#### ut::expect

```cpp
template <class TExpr> concept expression =
  std::convertible_to<TExpr, bool> and printable<TExpr>;
```
<!-- .element: class="fragment" data-fragment-index="3" -->

---

```cpp
constexpr concepts::streamable auto& expect(
  concepts::expression auto expr,
  const std::source_location &location =
        std::source_location::current()) {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  if (not expr) {
    error(expr, location);
  }
  return std::cerr;
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
template <class TLhs, class TRhs>
  requires concepts::op<TLhs> or concepts::op<TRhs>
constexpr concepts::op auto operator==(TLhs lhs, TRhs rhs);
```
<!-- .element: class="fragment" data-fragment-index="6" -->

----

#### ut::expect - https://godbolt.org/z/6Nk5Mi

```cpp
01 import ut;              // ‚úîÔ∏è
02
03 int main() {
04   expect(sum(1, 2) == 21_i) << '?';
05 }
```
<!-- .element: class="fragment" -->

---

<pre><code>expect.cpp:04:FAILED [3 == 21] ?</code> -> <font color="lime">‚úîÔ∏è</font></pre>
<!-- .element: class="fragment" -->

----

#### ut::suite

```cpp
template <class TSuite>
concept suite = std::invocable<TSuite>;
```
<!-- .element: class="fragment" data-fragment-index="3" -->

---

```cpp
struct suite {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  [[nodiscard]] constexpr explicit(false)
  suite(concepts::suite auto suite) {
    suite();
  }
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
};
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### ut::suite / ut::expect

```cpp
01 import ut;        // ‚úîÔ∏è
02
03 suite sums = [] { // ‚úîÔ∏è
04  "sum with no args"_test       = [] { expect(sum() == 0_i); };
05  "sum with single arg"_test    = [] { expect(sum(42) == 42_i); };
06  "sum with multiple args"_test = [] { expect(sum(1, 2) == 3_i); };
07 };
08
09 int main() {
10 }
```
<!-- .element: class="fragment" -->

---

<pre><code>Running... sum with no args
Running... sum with single arg
Running... sum with multiple args
</code> -> <font color="lime">‚úîÔ∏è</font></pre>
<!-- .element: class="fragment" -->

----

### Achievement Unlocked (Second goal)

### üëç

<!-- .slide: data-background="green" -->

----

#### Full implementation at:

* #### https://github.com/boost-ext/ut/tree/gh-pages/accu-2021/example
<!-- .element: class="fragment" -->

* #### Header - https://godbolt.org/z/a7Mses
<!-- .element: class="fragment" -->

* #### Module - https://wandbox.org/permlink/LRz6YCZJX9aff34x
<!-- .element: class="fragment" -->

==============================================================================

### UT - Unit Testing Framework

#### https://github.com/boost-ext/ut

----

#### UT - Overview

* #### C++20 ([GCC-9+, Clang-9.0+, Apple Clang-11.0.0+](https://travis-ci.org/boost-ext/ut), [MSVC-2019+*](https://ci.appveyor.com/project/boost-ext/ut))
<!-- .element: class="fragment" data-fragment-index="1" -->

* #### Single [header/module](https://github.com/boost-ext/ut/blob/master/include/boost/ut.hpp) (2k LOC) with no external dependencies
<!-- .element: class="fragment" data-fragment-index="2" -->

* #### Macro-free (‚úîÔ∏è)
<!-- .element: class="fragment" data-fragment-index="3" -->

* #### Features ([Assertions](https://github.com/boost-ext/ut/tree/master/example/expect.cpp), [Suites](https://github.com/boost-ext/ut/tree/master/example/suite.cpp), [Tests](https://github.com/boost-ext/ut/tree/master/example/skip.cpp), [Sections](https://github.com/boost-ext/ut/tree/master/example/section.cpp), [BDD](https://github.com/boost-ext/ut/tree/master/example/BDD.cpp), [Matchers](https://github.com/boost-ext/ut/tree/master/example/matcher.cpp), [Logging](https://github.com/boost-ext/ut/tree/master/example/log.cpp), [...](https://github.com/boost-ext/ut/tree/master/example))
<!-- .element: class="fragment" data-fragment-index="4" -->

---

* #### (\*) Limitations may apply
<!-- .element: class="fragment" data-fragment-index="1" -->

* #### UT is not an official Boost library
<!-- .element: class="fragment" data-fragment-index="6" -->

----

#### Hello World - https://godbolt.org/z/Y43mXz

<a href="https://godbolt.org/z/Jqb5Ye"><img src="images/ut.png" style="width: 100%; background:none; border:none; box-shadow:none;" /></a>

----

#### UT main - https://godbolt.org/z/f1ba1j

```cpp
auto ut_main(int argc, const char** argv) -> int {
  cfg<override> = {.filter = argv[1]};
  return cfg<override>.run();
}
```

----

#### main - https://godbolt.org/z/f1ba1j

```cpp
auto main(int argc, const char** argv) -> int {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  "empty"_test       = []{};
  "single"_test      = []{};
  "many"_test        = []{
    "equal"_test     = []{};
    "not equal"_test = []{};
  };
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```
  return ut_main(argc, argv);
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

<pre><code>./main "*"  # Regex-like syntax is supported</code> -> <font color="lime">All tests passed</font> (0 asserts in 3 tests)</pre>
<!-- .element: class="fragment" data-fragment-index="3" -->

<pre><code>./main "single*"</code> -> <font color="lime">All tests passed</font> (0 asserts in 1 tests)</pre>
<!-- .element: class="fragment" data-fragment-index="4" -->

<pre><code>./main "many.equal*" # Dot(.) is used to distinguish sub-tests</code> -> <font color="lime">All tests passed</font> (0 asserts in 1 tests)</pre>
<!-- .element: class="fragment" data-fragment-index="5" -->

----

#### Tags - https://godbolt.org/z/X3_kG4

```cpp
tag("nightly") / tag("slow") /
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
"performance"_test= [] {
  expect(42_i == 42);
};
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
skip /
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
"don't run"_test = [] {
  expect(42_i == 43) << "should not fire!";
};
```
<!-- .element: class="fragment" data-fragment-index="3" -->

---

```cpp
cfg<override> = {.tag = {"nightly"}};
```
<!-- .element: class="fragment" data-fragment-index="5" -->

<pre>-> <font color="lime">All tests passed</font> (1 asserts in 1 tests)
   1 tests skipped</pre>
<!-- .element: class="fragment" data-fragment-index="6" -->

----

#### Assertions - https://godbolt.org/z/jaFK8w

<pre><code class="line-numbers">1_i == 2;                               // Terse syntax</code>  -> assertions.cpp:1:<font color="salmon">FAILED</font> [<font color="salmon">1 == 2</font>]</pre>
<!-- .element: class="fragment" data-fragment-index="1" -->

<pre><code class="line-numbers">expect(2 == 1_i);                       // Expect syntax</code>  -> assertions.cpp:1:<font color="salmon">FAILED</font> [<font color="salmon">2 == 1</font>]</pre>
<!-- .element: class="fragment" data-fragment-index="2" -->

<pre><code class="line-numbers">expect(that % 1 == 2);                  // Matchers syntax</code>  -> assertions.cpp:1:<font color="salmon">FAILED</font> [<font color="salmon">1 == 2</font>]</pre>
<!-- .element: class="fragment" data-fragment-index="3" -->

<pre><code class="line-numbers">std::vector v{1l, 2l, 3l};
(4_ul == std::size(v)) >> fatal;        // Fatal assertion
v[3] == 4_l;                            // Not executed
</code>  -> assertions.cpp:2:<font color="salmon">FAILED</font> [<font color="salmon">4 == 3</font>]</pre>
<!-- .element: class="fragment" data-fragment-index="4" -->

<pre><code class="line-numbers">41.10_d == 42.101 and "a" == "b"sv;    // Compound expression
                                       // with floating-point</code>  -> assertions.cpp:1:<font color="salmon">FAILED</font> [<font color="lime">42.1 == 42.101</font> <font color="salmon">and a == b</font>]</pre>
<!-- .element: class="fragment" data-fragment-index="5" -->

----

#### Misc/Logging - https://godbolt.org/z/rnanxr

<pre><code class="line-numbers">(1_i == 2) << "should equal?";</code>  -> assertions.cpp:1:<font color="salmon">FAILED</font> [<font color="salmon">1 == 2</font>] should equal?</pre>
<!-- .element: class="fragment" data-fragment-index="1" -->

<pre><code class="line-numbers">expect(1_i == 2) << "should equal?";</code>  -> assertions.cpp:1:<font color="salmon">FAILED</font> [<font color="salmon">1 == 2</font>] should equal?</pre>
<!-- .element: class="fragment" data-fragment-index="2" -->

<pre><code class="line-numbers">log << "I'm here!";</code>  -> assertions.cpp:1:I'm here!</pre>
<!-- .element: class="fragment" data-fragment-index="3" -->

----

#### Sections - https://godbolt.org/z/y9m5vF

```cpp
"[vector]"_test = [] {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  // set up (1)
  std::vector<int> v(5);
  (5_ul == std::size(v)) >> fatal;
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  should("resize bigger") = [v] { // section (2.1)
    mut(v).resize(10);
    10_ul == std::size(v);
  };
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
  (5_ul == std::size(v)) >> fatal; // (3)
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
  should("resize smaller") = [v] { // section (2.2)
    mut(v).resize(0);
    0_ul == std::size(v);
  };
```
<!-- .element: class="fragment" data-fragment-index="5" -->

```cpp
  // tear down (4)
```
<!-- .element: class="fragment" data-fragment-index="6" -->

```cpp
};
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### Suites - https://godbolt.org/z/7P3Ph1

```cpp
suite errors = [] {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  "exception"_test = [] {
     expect(throws([] { throw 0; })) << "throws any exception";
     expect(throws<std::runtime_error>([] {
       throw std::runtime_error{"error"}; })
     );
  };

  "failure"_test = [] {
     expect(aborts([] { assert(false); }));
   };
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
};
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

<pre><code>int main() { }</code> -> <font color="lime">All tests passed</font> (3 asserts in 1 tests)</pre>
<!-- .element: class="fragment" data-fragment-index="3" -->

----

#### Parameterized - https://godbolt.org/z/6FHtpq

```cpp
for (auto i : std::vector{1, 2, 3}) {
  test("args " + std::to_string(i)) = [i] {
    expect(arg > 0_i) << "all values greater than 0";
  };
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

<pre>-> <font color="lime">All tests passed</font> (3 asserts in 3 tests)</pre>
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
"args and types"_test =
  []<class TArg>(TArg arg) {
    expect(std::is_integral_v<TArg>);
    expect(type<TArg> == type<int> or type<TArg> == type<bool>);
  }
```
<!-- .element: class="fragment" data-fragment-index="4" -->

<pre><code>| std::tuple{true, 42};</code> -> <font color="lime">All tests passed</font> (4 asserts in 2 tests)</pre>
<!-- .element: class="fragment" data-fragment-index="5" -->

----

#### Template metaprogramming - https://godbolt.org/z/9oh97x

```cpp
01 constexpr auto i = 0;
02 constant<42_i == i> and type<void> == type<int>;
```
<!-- .element: class="fragment" data-fragment-index="1" -->

<pre>-> meta-programming.cpp:2:<font color="salmon">FAILED</font> [(<font color="salmon">42 == 0 and void == int</font>)]</pre>
<!-- .element: class="fragment" data-fragment-index="2" -->

----

#### Spec - https://godbolt.org/z/6jKKzT

```cpp
describe("vector") = [] {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  std::vector<int> v(5);
  expect((5_ul == std::size(v)) >> fatal);
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  it("should resize bigger") = [v] {
    mut(v).resize(10);
    expect(10_ul == std::size(v));
  };
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
};
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

<pre>-> <font color="lime">All tests passed</font> (2 asserts in 1 tests)</pre>
<!-- .element: class="fragment" data-fragment-index="4" -->

----

#### Behavior Driven Development (`BDD`) - https://godbolt.org/z/4Mdo3K

```cpp
feature("vector") = [] {
  scenario("size") = [] {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
    given("I have a vector") = [] {
      std::vector<int> v(5);
      expect((5_ul == std::size(v)) >> fatal);
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
      when("I resize bigger") = [v] {
        mut(v).resize(10);
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
        then("The size should increase") = [v] {
          expect(10_ul == std::size(v));
        };
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
      };
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
  };
};
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

<pre>-> <font color="lime">All tests passed</font> (2 asserts in 1 tests)</pre>
<!-- .element: class="fragment" data-fragment-index="5" -->

----

#### Gherkin - https://godbolt.org/z/jb1d8P

---

###### vector.feature
<!-- .element: class="fragment" data-fragment-index="0" -->

```gherkin
Feature: Vector
  Scenario: Resize
    Given I have a vector
     When I resize bigger
     Then The size should increase
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### Gherkin - https://godbolt.org/z/jb1d8P

---

###### vector.cpp
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
gherkin::steps steps = [](auto& steps) {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  steps.feature("Vector") = [&] {
    steps.scenario("*") = [&] {
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
      steps.given("I have a vector") = [&] {
        std::vector<int> v(5);
        steps.when("I resize bigger") = [&] { v.resize(10); };
        steps.then("The size should increase") = [&] {
          expect(10_ul == std::size(v));
        };
      };
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
    };
  };
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
};
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

#### Gherkin - https://godbolt.org/z/jb1d8P

```cpp
int main() {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  "gherkin"_test = steps | "vector.feature"_file;
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

<pre>-> <font color="lime">All tests passed</font> (2 asserts in 1 tests)</pre>
<!-- .element: class="fragment" data-fragment-index="3" -->

----

#### Parallel execution - https://godbolt.org/z/M7z1qv

```cpp
suite parallel_1 = [] {
  "test.1.1"_test = [] { expect(1_i == 1); };
  "test.1.2"_test = [] { expect(2_i == 2); };
};
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
suite parallel_2 = [] {
  "test.2.1"_test = [] { expect(1_i == 1); };
  "test.2.2"_test = [] { expect(2_i == 2); };
};
```
<!-- .element: class="fragment" data-fragment-index="2" -->

---

```cpp
template <> auto cfg<ut::override> = parallel_runner{};
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
./parallel    ./parallel
test.2.1      test.1.1
test.2.2      test.1.2
test.1.1      test.2.1
test.1.2      test.2.2
```
<!-- .element: class="fragment" data-fragment-index="4" -->

<pre><code></code> -> <font color="lime">All tests passed</font> (4 asserts in 4 tests)</pre>
<!-- .element: class="fragment" data-fragment-index="5" -->

----

#### Benchmarking - https://godbolt.org/z/WqznMn

```cpp
auto do_not_optimize(auto expr) -> void {
  asm volatile("" :: "m"(expr) : "memory");
}
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
"string creation"_benchmark = [] {
  std::string created_string{"hello"};
  do_not_optimize(created_string);
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
[string creation] 3749 ns
```
<!-- .element: class="fragment" data-fragment-index="3" -->

<pre><code></code> -> <font color="lime">All tests passed</font> (0 asserts in 1 tests)</pre>
<!-- .element: class="fragment" data-fragment-index="3" -->

----

#### And much more at:

#### https://github.com/boost-ext/ut
<!-- .element: class="fragment" -->

==============================================================================

### Benchmarks

#### https://github.com/cpp-testing/ut-benchmark

----

#### Benchmarks - Frameworks

<img src="images/frameworks.png" style="width: 90%; background:none; border:none; box-shadow:none;" />

----

#### Benchmarks - [Include](https://github.com/cpp-testing/ut-benchmark)

<a href="images/Compilation_include.png"><img src="images/Compilation_include.png" style="width: 50%; background:none; border:none; box-shadow:none;" /></a>

##### 0 tests, 0 asserts, 1 cpp file

----

#### Benchmarks - [Suite+Assert+STL](https://github.com/cpp-testing/ut-benchmark)

<a href="images/Compilation_suite+assert+stl.png"><img src="images/Compilation_suite+assert+stl.png" style="width: 30%; background:none; border:none; box-shadow:none;" /></a>
<a href="images/Execution_suite+assert+stl.png"><img src="images/Execution_suite+assert+stl.png" style="width: 30%; background:none; border:none; box-shadow:none;" /></a>
<a href="images/BinarySize_suite+assert+stl.png"><img src="images/BinarySize_suite+assert+stl.png" style="width: 30%; background:none; border:none; box-shadow:none;" /></a>
<!-- .element: style="margin-left:-15%; width:130%" -->

#### 10'000 tests, 20'000 asserts, 100 cpp files

----

#### Benchmarks - [Incremental Build](https://github.com/cpp-testing/ut-benchmark)

<a href="images/Compilation_incremental.suite+assert+stl.png"><img src="images/Compilation_incremental.suite+assert+stl.png" style="width: 30%; background:none; border:none; box-shadow:none;" /></a>
<a href="images/Execution_incremental.suite+assert+stl.png"><img src="images/Execution_incremental.suite+assert+stl.png" style="width: 30%; background:none; border:none; box-shadow:none;" /></a>
<a href="images/BinarySize_incremental.suite+assert+stl.png"><img src="images/BinarySize_incremental.suite+assert+stl.png" style="width: 30%; background:none; border:none; box-shadow:none;" /></a>
<!-- .element: style="margin-left:-15%; width:130%" -->

#### 1 cpp file change (1'000 tests, 20'000 asserts, 100 cpp files)

----

#### Benchmarks - [Headers vs Precompiled headers vs C++20 Modules](https://github.com/cpp-testing/ut-benchmark)

<a href="images/ut_Compilation_suite+assert+stl.png"><img src="images/ut_Compilation_suite+assert+stl.png" style="width: 30%; background:none; border:none; box-shadow:none;" /></a>
<a href="images/ut_Execution_suite+assert+stl.png"><img src="images/ut_Execution_suite+assert+stl.png" style="width: 30%; background:none; border:none; box-shadow:none;" /></a>
<a href="images/ut_BinarySize_suite+assert+stl.png"><img src="images/ut_BinarySize_suite+assert+stl.png" style="width: 30%; background:none; border:none; box-shadow:none;" /></a>
<!-- .element: style="margin-left:-15%; width:130%" -->

#### 10'000 tests, 20'000 asserts, 100 cpp files

==============================================================================

### Summary

* #### C++20 enables a cleaner design and implementation
<!-- .element: class="fragment" data-fragment-index="1" -->

* #### UT is an example of cutting edge Unit Testing Framework
<!-- .element: class="fragment" data-fragment-index="2" -->

* #### Possible standardization of Unit Testing primitives?
<!-- .element: class="fragment" data-fragment-index="3" -->

* #### Macro-based Frameworks can be built on top of Unit Testing primitives
<!-- .element: class="fragment" data-fragment-index="4" -->

----

#### Catch2 - https://godbolt.org/z/jfb7jK

```cpp
#define REQUIRE(...)   ut::expect(that % __VA_ARGS__)
#define TEST_CASE(...) ut::test{"test", __VA_ARGS__} = [=]() mutable
#define SECTION(name)  ut::test{"section", name} = [=]() mutable
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
TEST_CASE("vectors can be sized and resized", "[vector]") {
  std::vector<int> v(5);

  SECTION("resize bigger") {
    v.resize(10);
    REQUIRE(10 == std::size(v));
  };
};
```
<!-- .element: class="fragment" data-fragment-index="2" -->

---

<pre><code>./catch2</code> -> <font color="lime">All tests passed</font> (1 asserts in 1 tests)</pre>
<!-- .element: class="fragment" data-fragment-index="3" -->

==============================================================================

<a href="https://www.quantlab.com/careers"><img src="images/quantlab-logo.svg" style="width: 35%; background:none; border:none; box-shadow:none;" /></a>

---

### If you liked it then you _"should have put a"_test_ on it!

#### _Beyonce rule_

---

#### https://www.quantlab.com/careers
          </script>
        </section>

      </div>
    </div>

    <script src="reveal.js/lib/js/head.min.js"></script>
    <script src="reveal.js/js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({

        // Display controls in the bottom right corner
        controls: false,

        // Display a presentation progress bar
        progress: false,

        // Display the page number of the current slide
        slideNumber: 'c/t',

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // Hides the address bar on mobile devices
        hideAddressBar: true,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style
        transition: 'none', // none/fade/slide/convex/concave/zoom

        // Transition speed
        transitionSpeed: 'default', // default/fast/slow

        // Transition style for full page slide backgrounds
        backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Parallax background image
        parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // Parallax background size
        parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

        // Number of pixels to move the parallax background per slide
        // - Calculated automatically unless specified
        // - Set to 0 to disable movement along an axis
        parallaxBackgroundHorizontal: null,
        parallaxBackgroundVertical: null,

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true },
          { src: 'extensions/plugin/line-numbers/line-numbers.js' }
        ]
      });

      <!--window.addEventListener("mousedown", handleClick, false);-->
      <!--window.addEventListener("contextmenu", function(e) { e.preventDefault(); }, false);-->

      function handleClick(e) {
        if (1 >= outerHeight - innerHeight) {
          document.querySelector( '.reveal' ).style.cursor = 'none';
        } else {
          document.querySelector( '.reveal' ).style.cursor = '';
        }

        e.preventDefault();
        if(e.button === 0) Reveal.next();
        if(e.button === 2) Reveal.prev();
      }
    </script>

  </body>
</html>
